{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dokumentasi Samudra Samudra (\u0633\u0627\u0645\u0648\u062f\u0631\u0627) ialah sebuah aplikasi untuk memudahkan pencatatan istilah serta pengongsiannya. Dengan memudahkan proses ini, jumlah rujukan bahasa Melayu dalam talian dapat ditingkatkan sekaligus menggalakkan perkembangannya dari segi penggunaan, penyelidikan serta pembelajarannya. Nama 'samudra' diambil sempena perkataan 'samudera' yang bererti lautan bagi menggambarkan kosa kata seluas lautan.","title":"Pengenalan"},{"location":"#dokumentasi-samudra","text":"Samudra (\u0633\u0627\u0645\u0648\u062f\u0631\u0627) ialah sebuah aplikasi untuk memudahkan pencatatan istilah serta pengongsiannya. Dengan memudahkan proses ini, jumlah rujukan bahasa Melayu dalam talian dapat ditingkatkan sekaligus menggalakkan perkembangannya dari segi penggunaan, penyelidikan serta pembelajarannya. Nama 'samudra' diambil sempena perkataan 'samudera' yang bererti lautan bagi menggambarkan kosa kata seluas lautan.","title":"Dokumentasi Samudra"},{"location":"model/","text":"Model Samudra Sebuah model samudra merujuk kepada objek atau class yang dipadankan dengan jadual dalam pangkalan data. Pemadanan dan interaksi dengan pangkalan data diuruskan oleh pakej peewee dan berperanan mentakrifkan bentuk data serta hubungkait sesama data. Setiap model tersimpan dalam direktori samudra/models dan mewarisi BaseModel yang mempunyai dua medan asasi: id dan tarikh_masuk . Pengembangan dan perkemasan model sedang dijalankan di cabang expand-model . Data Kamus Model Utama Buat masa ini terdapat 4 model yang berfungsi memegang data kata-kata: Lemma Konsep Cakupan KataAsing Hubungkait antara setiap model digambarkan sebegini: Model Pengantara Model Cakupan dan KataAsing bersambungan dengan Konsep secara padanan banyak kepada banyak. Oleh itu, perlunya ada model pengantara yang memegang data perhubungan tersebut: CakupanXKonsep KataAsingXKonsep Rujukan Maklumat lanjut boleh rujuk Models","title":"Model"},{"location":"model/#model-samudra","text":"Sebuah model samudra merujuk kepada objek atau class yang dipadankan dengan jadual dalam pangkalan data. Pemadanan dan interaksi dengan pangkalan data diuruskan oleh pakej peewee dan berperanan mentakrifkan bentuk data serta hubungkait sesama data. Setiap model tersimpan dalam direktori samudra/models dan mewarisi BaseModel yang mempunyai dua medan asasi: id dan tarikh_masuk . Pengembangan dan perkemasan model sedang dijalankan di cabang expand-model .","title":"Model Samudra"},{"location":"model/#data-kamus","text":"","title":"Data Kamus"},{"location":"model/#model-utama","text":"Buat masa ini terdapat 4 model yang berfungsi memegang data kata-kata: Lemma Konsep Cakupan KataAsing Hubungkait antara setiap model digambarkan sebegini:","title":"Model Utama"},{"location":"model/#model-pengantara","text":"Model Cakupan dan KataAsing bersambungan dengan Konsep secara padanan banyak kepada banyak. Oleh itu, perlunya ada model pengantara yang memegang data perhubungan tersebut: CakupanXKonsep KataAsingXKonsep","title":"Model Pengantara"},{"location":"model/#rujukan","text":"Maklumat lanjut boleh rujuk Models","title":"Rujukan"},{"location":"pemasangan/","text":"Pemasangan Prasyarat Python 3.8 atau lebih tinggi Poetry untuk pengurusan keperluan projek Git untuk kawalan perubahan kod Pemasangan # 1. Salin repositori ini guna git ke dalam folder bernama 'samudra' $ git clone https://github.com/Thaza-Kun/samudra.git samudra # 2. Masuk ke dalam folder samudra $ cd samudra # 3. Dapatkan semua keperluan projek menggunakan poetry $ poetry install Sediakan fail .env Sebelum boleh memulakan pelayan, fail .env perlu wujud untuk menyediakan nilai yang berlainan bagi setiap salinan aplikasi. Fail ini terletak dalam ROOT, iaitu tempat yang sama wujudnya pyproject.toml . Biasanya, nilai-nilai yang diletakkan dalam ini adalah nilai-nilai rahsia yang tidak boleh dikomit masuk git. Berikut merupakan nilai-nilai yang perlu ada dalam fail .env samudra: # ./.env # Buat masa sekarang ada tiga enjin: SQLite, MySQL, dan CockroachDB. # SQLite sesuai untuk aplikasi lokal dan hanya satu pengguna. # Yang lain memerlukan pelayan ENGINE = SQLite # Yang ini adalah nilai yang diperlukan untuk daftar masuk pelayan DB # (Tidak perlu kalau pilih enjin SQLite) DATABASE_USERNAME = DATABASE_PASSWORD = # Maklumat pelayan DB # (Tidak perlu kalau pilih enjin SQLite) DATABASE_NAME = DATABASE_HOST = DATABASE_PORT = DATABASE_OPTIONS = # Tempoh masa pengguna dibenarkan log masuk (dalam sukatan minit) # (Wajib walaupun pilih enjin SQLite) ACCESS_TOKEN_EXPIRE_MINUTES = Mulakan pelayan Setelah selesai langkah pemasangan, mulakan pelayan menggunakan poetry (poetry digunakan bagi memastikan arahan dalam fail python dilaksanakan menggunakan keperluan yang sudah dijelaskan dalam fail pyproject.toml ) $ poetry run python ./samudra/serve.py Jika anda menerima ralat mengenai nilai-nilai yang tidak tertakrif, rujuk bahagian fail .env . Lihat sekiranya nilai-nilai yang tersenarai di situ sudah tertakrif belum. Sekiranya nilai ralat itu tidak disenaraikan, boleh failkan isu.","title":"Aplikasi"},{"location":"pemasangan/#pemasangan","text":"","title":"Pemasangan"},{"location":"pemasangan/#prasyarat","text":"Python 3.8 atau lebih tinggi Poetry untuk pengurusan keperluan projek Git untuk kawalan perubahan kod","title":"Prasyarat"},{"location":"pemasangan/#pemasangan_1","text":"# 1. Salin repositori ini guna git ke dalam folder bernama 'samudra' $ git clone https://github.com/Thaza-Kun/samudra.git samudra # 2. Masuk ke dalam folder samudra $ cd samudra # 3. Dapatkan semua keperluan projek menggunakan poetry $ poetry install","title":"Pemasangan"},{"location":"pemasangan/#sediakan-fail-env","text":"Sebelum boleh memulakan pelayan, fail .env perlu wujud untuk menyediakan nilai yang berlainan bagi setiap salinan aplikasi. Fail ini terletak dalam ROOT, iaitu tempat yang sama wujudnya pyproject.toml . Biasanya, nilai-nilai yang diletakkan dalam ini adalah nilai-nilai rahsia yang tidak boleh dikomit masuk git. Berikut merupakan nilai-nilai yang perlu ada dalam fail .env samudra: # ./.env # Buat masa sekarang ada tiga enjin: SQLite, MySQL, dan CockroachDB. # SQLite sesuai untuk aplikasi lokal dan hanya satu pengguna. # Yang lain memerlukan pelayan ENGINE = SQLite # Yang ini adalah nilai yang diperlukan untuk daftar masuk pelayan DB # (Tidak perlu kalau pilih enjin SQLite) DATABASE_USERNAME = DATABASE_PASSWORD = # Maklumat pelayan DB # (Tidak perlu kalau pilih enjin SQLite) DATABASE_NAME = DATABASE_HOST = DATABASE_PORT = DATABASE_OPTIONS = # Tempoh masa pengguna dibenarkan log masuk (dalam sukatan minit) # (Wajib walaupun pilih enjin SQLite) ACCESS_TOKEN_EXPIRE_MINUTES =","title":"Sediakan fail .env"},{"location":"pemasangan/#mulakan-pelayan","text":"Setelah selesai langkah pemasangan, mulakan pelayan menggunakan poetry (poetry digunakan bagi memastikan arahan dalam fail python dilaksanakan menggunakan keperluan yang sudah dijelaskan dalam fail pyproject.toml ) $ poetry run python ./samudra/serve.py Jika anda menerima ralat mengenai nilai-nilai yang tidak tertakrif, rujuk bahagian fail .env . Lihat sekiranya nilai-nilai yang tersenarai di situ sudah tertakrif belum. Sekiranya nilai ralat itu tidak disenaraikan, boleh failkan isu.","title":"Mulakan pelayan"},{"location":"teras/","text":"Teknologi Teras Berikut merupakan teknologi teras yang menggerakkan Samudra dari dalam: Python ^3.8 Samudra bahagian pelayan ditulis dalam bahasa Python. Peewee ^3.15.1 Peewee merupakan pengurus pangkalan data dalam bentuk objek Python (iaitu sejenis ORM) yang ringan dan mudah digunakan. Setiap data dibentuk sebagai satu model . FastAPI ^0.79.0 Fast API merupakan pengurus API yang membantu menghantar data yang diminta pihak pelanggan. Pydantic ^1.9.1 Pydantic merupakan pengurus bentuk data yang memastikan data yang berpindah dari fungsi ke fungsi atau dari pangkalan data ke API mematuhi bentuk yang ditakrifkan. Hal ini memastikan datanya kekal berintegriti. Secara asasnya, beginilah carta alir data dalam sebuah aplikasi Samudra: flowchart TB subgraph APP [\"Samudra\"] direction LR PW[Peewee] PYD[Pydantic] FAST[FastAPI] end subgraph WEB [\"Laman web\"] direction TB CLIENT[Pelanggan] end SQL_DB[(Pangkalan Data)] PYD <--> PW FAST <--> PYD PW <--> SQL_DB CLIENT <--> FAST","title":"Teras"},{"location":"teras/#teknologi-teras","text":"Berikut merupakan teknologi teras yang menggerakkan Samudra dari dalam: Python ^3.8 Samudra bahagian pelayan ditulis dalam bahasa Python. Peewee ^3.15.1 Peewee merupakan pengurus pangkalan data dalam bentuk objek Python (iaitu sejenis ORM) yang ringan dan mudah digunakan. Setiap data dibentuk sebagai satu model . FastAPI ^0.79.0 Fast API merupakan pengurus API yang membantu menghantar data yang diminta pihak pelanggan. Pydantic ^1.9.1 Pydantic merupakan pengurus bentuk data yang memastikan data yang berpindah dari fungsi ke fungsi atau dari pangkalan data ke API mematuhi bentuk yang ditakrifkan. Hal ini memastikan datanya kekal berintegriti. Secara asasnya, beginilah carta alir data dalam sebuah aplikasi Samudra: flowchart TB subgraph APP [\"Samudra\"] direction LR PW[Peewee] PYD[Pydantic] FAST[FastAPI] end subgraph WEB [\"Laman web\"] direction TB CLIENT[Pelanggan] end SQL_DB[(Pangkalan Data)] PYD <--> PW FAST <--> PYD PW <--> SQL_DB CLIENT <--> FAST","title":"Teknologi Teras"},{"location":"API/auth/","text":"create_pengguna ( pengguna ) POST /auth/daftar . Register user Parameters: Name Type Description Default pengguna PenggunaCreateDTO User required Raises: Type Description HTTPException 409 Exception. User already exist HTTPException 400 Bad Request Exception. Returns: Type Description schemas.DaftarResponse Source code in samudra/server/routes/auth.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @router . post ( \"/daftar\" , response_model = schemas . DaftarResponse ) def create_pengguna ( pengguna : PenggunaCreateDTO ): \"\"\"POST `/auth/daftar`. Register user Args: pengguna (PenggunaCreateDTO): User Raises: HTTPException: 409 Exception. User already exist HTTPException: 400 Bad Request Exception. Returns: [`schemas.DaftarResponse`][samudra.schemas.tables.user.DaftarResponse] \"\"\" try : pengguna = auth . get_pengguna_by_nama ( pengguna . nama ) raise HTTPException ( status_code = 409 , detail = \"User already exist\" ) except models . Pengguna . DoesNotExist : pengguna = auth . create_pengguna ( nama = pengguna . nama , katalaluan = pengguna . katalaluan ) return { \"pengguna\" : pengguna . nama , \"mesej\" : f \"Pengguna { pengguna . nama } telah berjaya didaftarkan!\" , } except SyntaxError as e : raise HTTPException ( status_code = 400 , detail = e . msg ) login_pengguna ( form_data = Depends ()) async POST /auth/logmasuk . Log in. Parameters: Name Type Description Default form_data OAuth2PasswordRequestForm username and password. Defaults to Depends(). Depends() Raises: Type Description HTTPException 401 Unauthorized Exception. Incorrect username or password. HTTPException 400 Bad Request Exception. Returns: Type Description schemas.LogMasukResponse Source code in samudra/server/routes/auth.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 @router . post ( \"/logmasuk\" , response_model = schemas . LogMasukResponse ) async def login_pengguna ( form_data : OAuth2PasswordRequestForm = Depends ()): \"\"\"POST `/auth/logmasuk`. Log in. Args: form_data (OAuth2PasswordRequestForm, optional): username and password. Defaults to Depends(). Raises: HTTPException: 401 Unauthorized Exception. Incorrect username or password. HTTPException: 400 Bad Request Exception. Returns: [`schemas.LogMasukResponse`][samudra.schemas.tables.user.LogMasukResponse] \"\"\" try : pengguna = auth . authenticate_pengguna ( form_data . username , form_data . password ) if not pengguna : raise HTTPException ( status_code = status . HTTP_401_UNAUTHORIZED , detail = \"Incorrect username or password\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : pengguna . nama }, expires_delta = access_token_expires ) return { \"pengguna\" : form_data . username , \"token\" : { \"access_token\" : access_token , \"token_type\" : \"bearer\" }, } except SyntaxError as e : raise HTTPException ( status_code = 400 , detail = e . msg )","title":"Auth"},{"location":"API/auth/#samudra.server.routes.auth.create_pengguna","text":"POST /auth/daftar . Register user Parameters: Name Type Description Default pengguna PenggunaCreateDTO User required Raises: Type Description HTTPException 409 Exception. User already exist HTTPException 400 Bad Request Exception. Returns: Type Description schemas.DaftarResponse Source code in samudra/server/routes/auth.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @router . post ( \"/daftar\" , response_model = schemas . DaftarResponse ) def create_pengguna ( pengguna : PenggunaCreateDTO ): \"\"\"POST `/auth/daftar`. Register user Args: pengguna (PenggunaCreateDTO): User Raises: HTTPException: 409 Exception. User already exist HTTPException: 400 Bad Request Exception. Returns: [`schemas.DaftarResponse`][samudra.schemas.tables.user.DaftarResponse] \"\"\" try : pengguna = auth . get_pengguna_by_nama ( pengguna . nama ) raise HTTPException ( status_code = 409 , detail = \"User already exist\" ) except models . Pengguna . DoesNotExist : pengguna = auth . create_pengguna ( nama = pengguna . nama , katalaluan = pengguna . katalaluan ) return { \"pengguna\" : pengguna . nama , \"mesej\" : f \"Pengguna { pengguna . nama } telah berjaya didaftarkan!\" , } except SyntaxError as e : raise HTTPException ( status_code = 400 , detail = e . msg )","title":"create_pengguna()"},{"location":"API/auth/#samudra.server.routes.auth.login_pengguna","text":"POST /auth/logmasuk . Log in. Parameters: Name Type Description Default form_data OAuth2PasswordRequestForm username and password. Defaults to Depends(). Depends() Raises: Type Description HTTPException 401 Unauthorized Exception. Incorrect username or password. HTTPException 400 Bad Request Exception. Returns: Type Description schemas.LogMasukResponse Source code in samudra/server/routes/auth.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 @router . post ( \"/logmasuk\" , response_model = schemas . LogMasukResponse ) async def login_pengguna ( form_data : OAuth2PasswordRequestForm = Depends ()): \"\"\"POST `/auth/logmasuk`. Log in. Args: form_data (OAuth2PasswordRequestForm, optional): username and password. Defaults to Depends(). Raises: HTTPException: 401 Unauthorized Exception. Incorrect username or password. HTTPException: 400 Bad Request Exception. Returns: [`schemas.LogMasukResponse`][samudra.schemas.tables.user.LogMasukResponse] \"\"\" try : pengguna = auth . authenticate_pengguna ( form_data . username , form_data . password ) if not pengguna : raise HTTPException ( status_code = status . HTTP_401_UNAUTHORIZED , detail = \"Incorrect username or password\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : pengguna . nama }, expires_delta = access_token_expires ) return { \"pengguna\" : form_data . username , \"token\" : { \"access_token\" : access_token , \"token_type\" : \"bearer\" }, } except SyntaxError as e : raise HTTPException ( status_code = 400 , detail = e . msg )","title":"login_pengguna()"},{"location":"API/golongan_kata/","text":"create_golongan_kata ( post , token = Depends ( oauth2_scheme )) CREATE /golongan/new/ . Creates word class with value defined in post . PROTECTED user token required. Parameters: Name Type Description Default post schemas . CreateGolonganKata A JSON Object to define models.GolonganKata required Returns: Type Description Union [ models . GolonganKata , schemas . CreateGolonganKata ] If successful: GolonganKata . If unsuccessful: schemas.CreateGolonganKata for helpful error messages. Source code in samudra/server/routes/golongan_kata.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @router . post ( \"/new\" ) def create_golongan_kata ( post : schemas . CreateGolonganKata , token : str = Depends ( oauth2_scheme ) ) -> Union [ models . GolonganKata , schemas . CreateGolonganKata ]: \"\"\"CREATE `/golongan/new/`. Creates word class with value defined in `post`. !!! important \"PROTECTED\" user `token` required. Args: post (schemas.CreateGolonganKata): A JSON Object to define [`models.GolonganKata`][samudra.models.core.konsep.GolonganKata] Returns: If successful: [`GolonganKata`][samudra.models.core.konsep.GolonganKata]. If unsuccessful: [`schemas.CreateGolonganKata`][samudra.schemas.input.annotated_text.CreateGolonganKata] for helpful error messages. \"\"\" try : return crud . create_golongan_kata ( data = post ) except ValueError as e : return HTTPException ( status_code = 400 , detail = e )","title":"Golongan Kata"},{"location":"API/golongan_kata/#samudra.server.routes.golongan_kata.create_golongan_kata","text":"CREATE /golongan/new/ . Creates word class with value defined in post . PROTECTED user token required. Parameters: Name Type Description Default post schemas . CreateGolonganKata A JSON Object to define models.GolonganKata required Returns: Type Description Union [ models . GolonganKata , schemas . CreateGolonganKata ] If successful: GolonganKata . If unsuccessful: schemas.CreateGolonganKata for helpful error messages. Source code in samudra/server/routes/golongan_kata.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @router . post ( \"/new\" ) def create_golongan_kata ( post : schemas . CreateGolonganKata , token : str = Depends ( oauth2_scheme ) ) -> Union [ models . GolonganKata , schemas . CreateGolonganKata ]: \"\"\"CREATE `/golongan/new/`. Creates word class with value defined in `post`. !!! important \"PROTECTED\" user `token` required. Args: post (schemas.CreateGolonganKata): A JSON Object to define [`models.GolonganKata`][samudra.models.core.konsep.GolonganKata] Returns: If successful: [`GolonganKata`][samudra.models.core.konsep.GolonganKata]. If unsuccessful: [`schemas.CreateGolonganKata`][samudra.schemas.input.annotated_text.CreateGolonganKata] for helpful error messages. \"\"\" try : return crud . create_golongan_kata ( data = post ) except ValueError as e : return HTTPException ( status_code = 400 , detail = e )","title":"create_golongan_kata()"},{"location":"API/lemma/","text":"create_lemma ( nama , post , token = Depends ( oauth2_scheme )) POST /lemma/{nama} . Inserts the lemma with value nama={nama} and post into the database. PROTECTED user token required Parameters: Name Type Description Default nama str the dictionary entry required post schemas . AnnotatedText An annotated text containing meaning, context, and foreign words. required Raises: Type Description HTTPException 400 Bad Query Exception if it has bad AnnotatedText. Returns: Type Description Union [ models . Konsep , schemas . AnnotatedText ] If successful: Konsep . If unsuccessful: schemas.AnnotatedText for helpful error messages. Source code in samudra/server/routes/lemmas.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @router . post ( \"/ {nama} \" , response_model = schemas . KonsepResponseFromAnnotatedBody ) def create_lemma ( nama : str , post : schemas . AnnotatedText , token : str = Depends ( oauth2_scheme ) ) -> Union [ models . Konsep , schemas . AnnotatedText ]: \"\"\"POST `/lemma/{nama}`. Inserts the lemma with value `nama={nama}` and `post` into the database. !!! important \"PROTECTED\" user `token` required Args: nama (str): the dictionary entry post (schemas.AnnotatedText): An annotated text containing meaning, context, and foreign words. Raises: HTTPException: 400 Bad Query Exception if it has bad AnnotatedText. Returns: If successful: [`Konsep`][samudra.models.core.konsep.Konsep]. If unsuccessful: [`schemas.AnnotatedText`][samudra.schemas.input.annotated_text.AnnotatedText] for helpful error messages. \"\"\" try : to_return = crud . create_konsep_by_annotated_text ( post , lemma_name = nama ) except SyntaxError as e : raise HTTPException ( status_code = 400 , detail = e . msg ) return to_return delete_lemma ( _id , token = Depends ( oauth2_scheme )) DELETE /lemma/id/{_id} . Deletes lemma with value id={_id} PROTECTED user token required Parameters: Name Type Description Default _id int Id of lemma required Returns: Type Description Dict [ str , int ] Returns how many items are deleted. Source code in samudra/server/routes/lemmas.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @router . delete ( \"/id/ {_id} \" , response_model = Dict [ str , int ]) def delete_lemma ( _id : int , token : str = Depends ( oauth2_scheme )) -> Dict [ str , int ]: \"\"\"DELETE `/lemma/id/{_id}`. Deletes lemma with value `id={_id}` !!! important \"PROTECTED\" user `token` required Args: _id (int): Id of lemma Returns: Returns how many items are deleted. \"\"\" lemma = crud . get_lemma_by_id ( _id )[ 0 ] return { \"deleted\" : crud . delete_lemma ( lemma )} get_all_lemma ( limit = Query ( default = None ), cakupan = Query ( default = None ), kata_asing = Query ( default = None )) GET /lemma/ . Queries all lemma within the defined query parameters. Parameters: Name Type Description Default limit Optional [ int ] Limit number of hits. Defaults to Query(default=None). Query(default=None) cakupan Optional [ List [ str ]] Context of meaning. Defaults to Query(default=None). Query(default=None) kata_asing Optional [ List [ str ]] Containing these foreign words. Defaults to Query(default=None). Query(default=None) Returns: Type Description List [ models . Lemma ] List[models.Lemma]: List of Lemma and its meaning. Source code in samudra/server/routes/lemmas.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @router . get ( \"/\" , response_model = List [ schemas . LemmaResponse ]) def get_all_lemma ( limit : Optional [ int ] = Query ( default = None ), cakupan : Optional [ List [ str ]] = Query ( default = None ), kata_asing : Optional [ List [ str ]] = Query ( default = None ), ) -> List [ models . Lemma ]: \"\"\"GET `/lemma/`. Queries all lemma within the defined query parameters. Args: limit (Optional[int], optional): Limit number of hits. Defaults to Query(default=None). cakupan (Optional[List[str]], optional): Context of meaning. Defaults to Query(default=None). kata_asing (Optional[List[str]], optional): Containing these foreign words. Defaults to Query(default=None). Returns: List[models.Lemma]: List of Lemma and its meaning. \"\"\" return crud . get_lemma ( QueryFilter ( limit = limit , cakupan = cakupan , kata_asing = kata_asing ) ) read_lemma ( nama , limit = Query ( default = None ), cakupan = Query ( default = None ), kata_asing = Query ( default = None )) GET /lemma/{nama} . Queries the database for lemma with value nama={nama} . Parameters: Name Type Description Default nama str the dictionary entry required limit Optional [ int ] Limit number of hits. Defaults to Query(default=None). Query(default=None) cakupan Optional [ List [ str ]] Context of meaning. Defaults to Query(default=None). Query(default=None) kata_asing Optional [ List [ str ]] Containing these foreign words. Defaults to Query(default=None). Query(default=None) Raises: Type Description HTTPException 404 Exception if no lemma found in record Returns: Type Description List [ models . Lemma ] List[models.Lemma]: List of Lemma and its meaning. Source code in samudra/server/routes/lemmas.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @router . get ( \"/ {nama} \" , response_model = List [ schemas . LemmaResponse ]) def read_lemma ( nama : str , limit : Optional [ int ] = Query ( default = None ), cakupan : Optional [ List [ str ]] = Query ( default = None ), kata_asing : Optional [ List [ str ]] = Query ( default = None ), ) -> List [ models . Lemma ]: \"\"\"GET `/lemma/{nama}`. Queries the database for lemma with value `nama={nama}`. Args: nama (str): the dictionary entry limit (Optional[int], optional): Limit number of hits. Defaults to Query(default=None). cakupan (Optional[List[str]], optional): Context of meaning. Defaults to Query(default=None). kata_asing (Optional[List[str]], optional): Containing these foreign words. Defaults to Query(default=None). Raises: HTTPException: 404 Exception if no lemma found in record Returns: List[models.Lemma]: List of Lemma and its meaning. \"\"\" db_lemma = crud . get_lemma_by_name ( nama = nama , query = QueryFilter ( limit = limit , cakupan = cakupan , kata_asing = kata_asing ), ) if db_lemma is None : raise HTTPException ( status_code = 404 , detail = \"Lemma not in record\" ) return db_lemma","title":"lemma"},{"location":"API/lemma/#samudra.server.routes.lemmas.create_lemma","text":"POST /lemma/{nama} . Inserts the lemma with value nama={nama} and post into the database. PROTECTED user token required Parameters: Name Type Description Default nama str the dictionary entry required post schemas . AnnotatedText An annotated text containing meaning, context, and foreign words. required Raises: Type Description HTTPException 400 Bad Query Exception if it has bad AnnotatedText. Returns: Type Description Union [ models . Konsep , schemas . AnnotatedText ] If successful: Konsep . If unsuccessful: schemas.AnnotatedText for helpful error messages. Source code in samudra/server/routes/lemmas.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @router . post ( \"/ {nama} \" , response_model = schemas . KonsepResponseFromAnnotatedBody ) def create_lemma ( nama : str , post : schemas . AnnotatedText , token : str = Depends ( oauth2_scheme ) ) -> Union [ models . Konsep , schemas . AnnotatedText ]: \"\"\"POST `/lemma/{nama}`. Inserts the lemma with value `nama={nama}` and `post` into the database. !!! important \"PROTECTED\" user `token` required Args: nama (str): the dictionary entry post (schemas.AnnotatedText): An annotated text containing meaning, context, and foreign words. Raises: HTTPException: 400 Bad Query Exception if it has bad AnnotatedText. Returns: If successful: [`Konsep`][samudra.models.core.konsep.Konsep]. If unsuccessful: [`schemas.AnnotatedText`][samudra.schemas.input.annotated_text.AnnotatedText] for helpful error messages. \"\"\" try : to_return = crud . create_konsep_by_annotated_text ( post , lemma_name = nama ) except SyntaxError as e : raise HTTPException ( status_code = 400 , detail = e . msg ) return to_return","title":"create_lemma()"},{"location":"API/lemma/#samudra.server.routes.lemmas.delete_lemma","text":"DELETE /lemma/id/{_id} . Deletes lemma with value id={_id} PROTECTED user token required Parameters: Name Type Description Default _id int Id of lemma required Returns: Type Description Dict [ str , int ] Returns how many items are deleted. Source code in samudra/server/routes/lemmas.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @router . delete ( \"/id/ {_id} \" , response_model = Dict [ str , int ]) def delete_lemma ( _id : int , token : str = Depends ( oauth2_scheme )) -> Dict [ str , int ]: \"\"\"DELETE `/lemma/id/{_id}`. Deletes lemma with value `id={_id}` !!! important \"PROTECTED\" user `token` required Args: _id (int): Id of lemma Returns: Returns how many items are deleted. \"\"\" lemma = crud . get_lemma_by_id ( _id )[ 0 ] return { \"deleted\" : crud . delete_lemma ( lemma )}","title":"delete_lemma()"},{"location":"API/lemma/#samudra.server.routes.lemmas.get_all_lemma","text":"GET /lemma/ . Queries all lemma within the defined query parameters. Parameters: Name Type Description Default limit Optional [ int ] Limit number of hits. Defaults to Query(default=None). Query(default=None) cakupan Optional [ List [ str ]] Context of meaning. Defaults to Query(default=None). Query(default=None) kata_asing Optional [ List [ str ]] Containing these foreign words. Defaults to Query(default=None). Query(default=None) Returns: Type Description List [ models . Lemma ] List[models.Lemma]: List of Lemma and its meaning. Source code in samudra/server/routes/lemmas.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @router . get ( \"/\" , response_model = List [ schemas . LemmaResponse ]) def get_all_lemma ( limit : Optional [ int ] = Query ( default = None ), cakupan : Optional [ List [ str ]] = Query ( default = None ), kata_asing : Optional [ List [ str ]] = Query ( default = None ), ) -> List [ models . Lemma ]: \"\"\"GET `/lemma/`. Queries all lemma within the defined query parameters. Args: limit (Optional[int], optional): Limit number of hits. Defaults to Query(default=None). cakupan (Optional[List[str]], optional): Context of meaning. Defaults to Query(default=None). kata_asing (Optional[List[str]], optional): Containing these foreign words. Defaults to Query(default=None). Returns: List[models.Lemma]: List of Lemma and its meaning. \"\"\" return crud . get_lemma ( QueryFilter ( limit = limit , cakupan = cakupan , kata_asing = kata_asing ) )","title":"get_all_lemma()"},{"location":"API/lemma/#samudra.server.routes.lemmas.read_lemma","text":"GET /lemma/{nama} . Queries the database for lemma with value nama={nama} . Parameters: Name Type Description Default nama str the dictionary entry required limit Optional [ int ] Limit number of hits. Defaults to Query(default=None). Query(default=None) cakupan Optional [ List [ str ]] Context of meaning. Defaults to Query(default=None). Query(default=None) kata_asing Optional [ List [ str ]] Containing these foreign words. Defaults to Query(default=None). Query(default=None) Raises: Type Description HTTPException 404 Exception if no lemma found in record Returns: Type Description List [ models . Lemma ] List[models.Lemma]: List of Lemma and its meaning. Source code in samudra/server/routes/lemmas.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @router . get ( \"/ {nama} \" , response_model = List [ schemas . LemmaResponse ]) def read_lemma ( nama : str , limit : Optional [ int ] = Query ( default = None ), cakupan : Optional [ List [ str ]] = Query ( default = None ), kata_asing : Optional [ List [ str ]] = Query ( default = None ), ) -> List [ models . Lemma ]: \"\"\"GET `/lemma/{nama}`. Queries the database for lemma with value `nama={nama}`. Args: nama (str): the dictionary entry limit (Optional[int], optional): Limit number of hits. Defaults to Query(default=None). cakupan (Optional[List[str]], optional): Context of meaning. Defaults to Query(default=None). kata_asing (Optional[List[str]], optional): Containing these foreign words. Defaults to Query(default=None). Raises: HTTPException: 404 Exception if no lemma found in record Returns: List[models.Lemma]: List of Lemma and its meaning. \"\"\" db_lemma = crud . get_lemma_by_name ( nama = nama , query = QueryFilter ( limit = limit , cakupan = cakupan , kata_asing = kata_asing ), ) if db_lemma is None : raise HTTPException ( status_code = 404 , detail = \"Lemma not in record\" ) return db_lemma","title":"read_lemma()"},{"location":"reference/SUMMARY/","text":"cli database golongan_kata lemma conf database core options local server cors_policy setup core auth pengguna crud cakupan golongan_kata kata_asing konsep lemma models auth pengguna base core cakupan kata_asing konsep lemma experimental petikan schemas input accepted_fields annotated_text query_filter tables _helper cakupan golongan_kata kata_asing konsep lemma user server dependencies routes auth golongan_kata lemmas setup tokens","title":"Ringkasan"},{"location":"reference/cli/","text":"","title":"Index"},{"location":"reference/cli/database/","text":"create ( name = typer . Argument ( Ellipsis , rich_help_panel = 'Name of database.' ), path = typer . Option ( '.' , rich_help_panel = 'Path to store database (SQLite)' ), experimental = typer . Option ( False , rich_help_panel = 'Include experimental tables' ), engine = typer . Option ( DatabaseEngine . SQLite . value , '--engine' , '-e' , rich_help_panel = 'Engine to use for database.' )) Creates a new database Source code in samudra/cli/database.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @app . command () def create ( name : str = typer . Argument ( ... , rich_help_panel = \"Name of database.\" ), path : str = typer . Option ( \".\" , rich_help_panel = \"Path to store database (SQLite)\" ), experimental : bool = typer . Option ( False , rich_help_panel = \"Include experimental tables\" ), engine : DatabaseEngine = typer . Option ( DatabaseEngine . SQLite . value , \"--engine\" , \"-e\" , rich_help_panel = \"Engine to use for database.\" , ), ) -> None : \"\"\"Creates a new database\"\"\" database = get_database ( db_name = name , engine = engine , path = path , new = True ) tables = create_tables ( database = database , auth = False , experimental = experimental , ) save_database ( db_name = name , path = Path ( path )) print ( f \"`samudra.db` has been created in { Path ( path , name ) . resolve () } with the following tables:\" ) [ print ( \"-\" , table ) for table in tables ] list () Lists available databases Source code in samudra/cli/database.py 43 44 45 46 47 @app . command () def list (): \"\"\"Lists available databases\"\"\" # TODO Print as tables print ( get_databases_config ()[ \"databases\" ])","title":"Database"},{"location":"reference/cli/database/#samudra.cli.database.create","text":"Creates a new database Source code in samudra/cli/database.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @app . command () def create ( name : str = typer . Argument ( ... , rich_help_panel = \"Name of database.\" ), path : str = typer . Option ( \".\" , rich_help_panel = \"Path to store database (SQLite)\" ), experimental : bool = typer . Option ( False , rich_help_panel = \"Include experimental tables\" ), engine : DatabaseEngine = typer . Option ( DatabaseEngine . SQLite . value , \"--engine\" , \"-e\" , rich_help_panel = \"Engine to use for database.\" , ), ) -> None : \"\"\"Creates a new database\"\"\" database = get_database ( db_name = name , engine = engine , path = path , new = True ) tables = create_tables ( database = database , auth = False , experimental = experimental , ) save_database ( db_name = name , path = Path ( path )) print ( f \"`samudra.db` has been created in { Path ( path , name ) . resolve () } with the following tables:\" ) [ print ( \"-\" , table ) for table in tables ]","title":"create()"},{"location":"reference/cli/database/#samudra.cli.database.list","text":"Lists available databases Source code in samudra/cli/database.py 43 44 45 46 47 @app . command () def list (): \"\"\"Lists available databases\"\"\" # TODO Print as tables print ( get_databases_config ()[ \"databases\" ])","title":"list()"},{"location":"reference/cli/golongan_kata/","text":"new ( id = typer . Argument ( Ellipsis , rich_help_panel = 'Identifying shorthand. Must be less than 6' ), nama = typer . Argument ( Ellipsis , rich_help_panel = 'Full name of the word class' ), keterangan = typer . Option ( '' , '--keterangan' , '-k' , rich_help_panel = 'The description of the word class' )) Creates a new word class. Source code in samudra/cli/golongan_kata.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @app . command () def new ( id : str = typer . Argument ( ... , rich_help_panel = \"Identifying shorthand. Must be less than 6\" ), nama : str = typer . Argument ( ... , rich_help_panel = \"Full name of the word class\" ), keterangan : str = typer . Option ( \"\" , \"--keterangan\" , \"-k\" , rich_help_panel = \"The description of the word class\" ), ): \"\"\"Creates a new word class.\"\"\" # TODO Only bind during instantiation bind_to_database ( database = access_database ( local = True ), auth = True , experimental = True ) crud . create_golongan_kata ( data = CreateGolonganKata ( id = id , nama = nama , keterangan = keterangan ) )","title":"Golongan kata"},{"location":"reference/cli/golongan_kata/#samudra.cli.golongan_kata.new","text":"Creates a new word class. Source code in samudra/cli/golongan_kata.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @app . command () def new ( id : str = typer . Argument ( ... , rich_help_panel = \"Identifying shorthand. Must be less than 6\" ), nama : str = typer . Argument ( ... , rich_help_panel = \"Full name of the word class\" ), keterangan : str = typer . Option ( \"\" , \"--keterangan\" , \"-k\" , rich_help_panel = \"The description of the word class\" ), ): \"\"\"Creates a new word class.\"\"\" # TODO Only bind during instantiation bind_to_database ( database = access_database ( local = True ), auth = True , experimental = True ) crud . create_golongan_kata ( data = CreateGolonganKata ( id = id , nama = nama , keterangan = keterangan ) )","title":"new()"},{"location":"reference/cli/lemma/","text":"","title":"Lemma"},{"location":"reference/conf/","text":"","title":"Konfig"},{"location":"reference/conf/local/","text":"","title":"Local"},{"location":"reference/conf/setup/","text":"","title":"Setup"},{"location":"reference/conf/database/","text":"","title":"Index"},{"location":"reference/conf/database/core/","text":"get_database ( db_name , engine , ** kwargs ) Returns the connection class based on the engine. Source code in samudra/conf/database/core.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def get_database ( db_name : str , engine : DatabaseEngine , ** kwargs ) -> pw . Database : \"\"\" Returns the connection class based on the engine. \"\"\" if engine is None or engine not in DatabaseEngine . __members__ . values (): raise ValueError ( \"Please specify database engine in conf.toml. You entered {} . Valid values are: \\n - {} \" . format ( engine , \" \\n - \" . join ( DatabaseEngine . __members__ . values ()) ) ) if engine == DatabaseEngine . SQLite : return get_sqlite ( folder = db_name , path = kwargs . pop ( \"path\" ), new = kwargs . pop ( \"new\" ), ** kwargs ) DATABASE_HOST = os . getenv ( \"DATABASE_HOST\" ) DATABASE_PORT = int ( os . getenv ( \"DATABASE_PORT\" )) DATABASE_OPTIONS = os . getenv ( \"DATABASE_OPTIONS\" ) USERNAME = os . getenv ( \"DATABASE_USERNAME\" ) PASSWORD = os . getenv ( \"DATABASE_PASSWORD\" ) SSL_MODE = os . getenv ( \"SSL_MODE\" ) if engine == DatabaseEngine . MySQL : conn_str = f \"mysql:// { USERNAME } : { PASSWORD } @ { DATABASE_HOST } : { DATABASE_PORT } / { db_name } ?ssl-mode=REQUIRED\" return_db = pw . MySQLDatabase ( conn_str ) logging . info ( f \"Connecting to { return_db . database } as { USERNAME } \" ) if engine == DatabaseEngine . CockroachDB : from playhouse.cockroachdb import CockroachDatabase conn_str = f \"postgresql:// { USERNAME } : { PASSWORD } @ { DATABASE_HOST } : { DATABASE_PORT } / { db_name } ?sslmode=verify-full&options= { DATABASE_OPTIONS } \" return_db = CockroachDatabase ( conn_str ) logging . info ( f \"Connecting to { return_db . database } as { USERNAME } \" ) else : raise NotImplementedError ( \"Invalid engine\" ) return return_db","title":"Core"},{"location":"reference/conf/database/core/#samudra.conf.database.core.get_database","text":"Returns the connection class based on the engine. Source code in samudra/conf/database/core.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def get_database ( db_name : str , engine : DatabaseEngine , ** kwargs ) -> pw . Database : \"\"\" Returns the connection class based on the engine. \"\"\" if engine is None or engine not in DatabaseEngine . __members__ . values (): raise ValueError ( \"Please specify database engine in conf.toml. You entered {} . Valid values are: \\n - {} \" . format ( engine , \" \\n - \" . join ( DatabaseEngine . __members__ . values ()) ) ) if engine == DatabaseEngine . SQLite : return get_sqlite ( folder = db_name , path = kwargs . pop ( \"path\" ), new = kwargs . pop ( \"new\" ), ** kwargs ) DATABASE_HOST = os . getenv ( \"DATABASE_HOST\" ) DATABASE_PORT = int ( os . getenv ( \"DATABASE_PORT\" )) DATABASE_OPTIONS = os . getenv ( \"DATABASE_OPTIONS\" ) USERNAME = os . getenv ( \"DATABASE_USERNAME\" ) PASSWORD = os . getenv ( \"DATABASE_PASSWORD\" ) SSL_MODE = os . getenv ( \"SSL_MODE\" ) if engine == DatabaseEngine . MySQL : conn_str = f \"mysql:// { USERNAME } : { PASSWORD } @ { DATABASE_HOST } : { DATABASE_PORT } / { db_name } ?ssl-mode=REQUIRED\" return_db = pw . MySQLDatabase ( conn_str ) logging . info ( f \"Connecting to { return_db . database } as { USERNAME } \" ) if engine == DatabaseEngine . CockroachDB : from playhouse.cockroachdb import CockroachDatabase conn_str = f \"postgresql:// { USERNAME } : { PASSWORD } @ { DATABASE_HOST } : { DATABASE_PORT } / { db_name } ?sslmode=verify-full&options= { DATABASE_OPTIONS } \" return_db = CockroachDatabase ( conn_str ) logging . info ( f \"Connecting to { return_db . database } as { USERNAME } \" ) else : raise NotImplementedError ( \"Invalid engine\" ) return return_db","title":"get_database()"},{"location":"reference/conf/database/options/","text":"","title":"Options"},{"location":"reference/conf/server/","text":"","title":"Index"},{"location":"reference/conf/server/cors_policy/","text":"","title":"Cors policy"},{"location":"reference/core/","text":"This module contains the core functions of the app. Currently it only has 2 submodules: CRUD Submodule Auth Submodule","title":"Teras"},{"location":"reference/core/auth/","text":"Functions relating to the management of Pengguna /pengguna","title":"Index"},{"location":"reference/core/auth/pengguna/","text":"Functions relating to the management of Pengguna authenticate_pengguna ( nama , katalaluan ) Authenticates a user Parameters: Name Type Description Default nama str username required katalaluan str password required Returns: Type Description models . Pengguna models.Pengguna: Pengguna Source code in samudra/core/auth/pengguna.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def authenticate_pengguna ( nama : str , katalaluan : str ) -> models . Pengguna : \"\"\"Authenticates a user Args: nama (str): username katalaluan (str): password Returns: models.Pengguna: [`Pengguna`][samudra.models.auth.Pengguna] \"\"\" pengguna : models . Pengguna = get_pengguna_by_nama ( nama ) if not pengguna : return False if not verify_password ( katalaluan , pengguna . kunci ): return False return pengguna create_pengguna ( nama , katalaluan , safe = True ) Creates a single row of Pengguna Parameters: Name Type Description Default nama str username required katalaluan str password required safe bool Try to get the existing row before creating. Defaults to True. True Returns: Type Description models . Pengguna models.Pengguna: Pengguna Source code in samudra/core/auth/pengguna.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def create_pengguna ( nama : str , katalaluan : str , safe : bool = True ) -> models . Pengguna : \"\"\"Creates a single row of [`Pengguna`][samudra.models.auth.Pengguna] Args: nama (str): username katalaluan (str): password safe (bool, optional): Try to get the existing row before creating. Defaults to True. Returns: models.Pengguna: [`Pengguna`][samudra.models.auth.Pengguna] \"\"\" if safe : return models . Pengguna . get_or_create ( nama = nama , kunci = get_password_hash ( katalaluan ) )[ 0 ] return models . Pengguna . create ( nama = nama , kunci = get_password_hash ( katalaluan )) get_password_hash ( password ) Gets the hash of a given password Parameters: Name Type Description Default password str Raw password given by the user. required Returns: Name Type Description str str Hashed password Source code in samudra/core/auth/pengguna.py 13 14 15 16 17 18 19 20 21 22 def get_password_hash ( password : str ) -> str : \"\"\"Gets the hash of a given password Args: password (str): Raw password given by the user. Returns: str: Hashed password \"\"\" return pwd_context . hash ( password ) get_pengguna_by_nama ( nama ) Gets a single row of Pengguna by its username. Parameters: Name Type Description Default nama str username required Returns: Type Description models . Pengguna models.Pengguna: Pengguna Source code in samudra/core/auth/pengguna.py 38 39 40 41 42 43 44 45 46 47 def get_pengguna_by_nama ( nama : str ) -> models . Pengguna : \"\"\"Gets a single row of [`Pengguna`][samudra.models.auth.Pengguna] by its username. Args: nama (str): username Returns: models.Pengguna: [`Pengguna`][samudra.models.auth.Pengguna] \"\"\" return prefetch ( models . Pengguna . get ( models . Pengguna . nama == nama )) verify_password ( plain_password , hashed_password ) Verify that the password is correct Parameters: Name Type Description Default plain_password str Raw password given by the user. required hashed_password str Hashed password given by get_password_hash required Returns: Name Type Description bool bool Verification status Source code in samudra/core/auth/pengguna.py 25 26 27 28 29 30 31 32 33 34 35 def verify_password ( plain_password : str , hashed_password : str ) -> bool : \"\"\"Verify that the password is correct Args: plain_password (str): Raw password given by the user. hashed_password (str): Hashed password given by [`get_password_hash`][samudra.core.auth.pengguna.get_password_hash] Returns: bool: Verification status \"\"\" return pwd_context . verify ( plain_password , hashed_password )","title":"Pengguna"},{"location":"reference/core/auth/pengguna/#samudra.core.auth.pengguna.authenticate_pengguna","text":"Authenticates a user Parameters: Name Type Description Default nama str username required katalaluan str password required Returns: Type Description models . Pengguna models.Pengguna: Pengguna Source code in samudra/core/auth/pengguna.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def authenticate_pengguna ( nama : str , katalaluan : str ) -> models . Pengguna : \"\"\"Authenticates a user Args: nama (str): username katalaluan (str): password Returns: models.Pengguna: [`Pengguna`][samudra.models.auth.Pengguna] \"\"\" pengguna : models . Pengguna = get_pengguna_by_nama ( nama ) if not pengguna : return False if not verify_password ( katalaluan , pengguna . kunci ): return False return pengguna","title":"authenticate_pengguna()"},{"location":"reference/core/auth/pengguna/#samudra.core.auth.pengguna.create_pengguna","text":"Creates a single row of Pengguna Parameters: Name Type Description Default nama str username required katalaluan str password required safe bool Try to get the existing row before creating. Defaults to True. True Returns: Type Description models . Pengguna models.Pengguna: Pengguna Source code in samudra/core/auth/pengguna.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def create_pengguna ( nama : str , katalaluan : str , safe : bool = True ) -> models . Pengguna : \"\"\"Creates a single row of [`Pengguna`][samudra.models.auth.Pengguna] Args: nama (str): username katalaluan (str): password safe (bool, optional): Try to get the existing row before creating. Defaults to True. Returns: models.Pengguna: [`Pengguna`][samudra.models.auth.Pengguna] \"\"\" if safe : return models . Pengguna . get_or_create ( nama = nama , kunci = get_password_hash ( katalaluan ) )[ 0 ] return models . Pengguna . create ( nama = nama , kunci = get_password_hash ( katalaluan ))","title":"create_pengguna()"},{"location":"reference/core/auth/pengguna/#samudra.core.auth.pengguna.get_password_hash","text":"Gets the hash of a given password Parameters: Name Type Description Default password str Raw password given by the user. required Returns: Name Type Description str str Hashed password Source code in samudra/core/auth/pengguna.py 13 14 15 16 17 18 19 20 21 22 def get_password_hash ( password : str ) -> str : \"\"\"Gets the hash of a given password Args: password (str): Raw password given by the user. Returns: str: Hashed password \"\"\" return pwd_context . hash ( password )","title":"get_password_hash()"},{"location":"reference/core/auth/pengguna/#samudra.core.auth.pengguna.get_pengguna_by_nama","text":"Gets a single row of Pengguna by its username. Parameters: Name Type Description Default nama str username required Returns: Type Description models . Pengguna models.Pengguna: Pengguna Source code in samudra/core/auth/pengguna.py 38 39 40 41 42 43 44 45 46 47 def get_pengguna_by_nama ( nama : str ) -> models . Pengguna : \"\"\"Gets a single row of [`Pengguna`][samudra.models.auth.Pengguna] by its username. Args: nama (str): username Returns: models.Pengguna: [`Pengguna`][samudra.models.auth.Pengguna] \"\"\" return prefetch ( models . Pengguna . get ( models . Pengguna . nama == nama ))","title":"get_pengguna_by_nama()"},{"location":"reference/core/auth/pengguna/#samudra.core.auth.pengguna.verify_password","text":"Verify that the password is correct Parameters: Name Type Description Default plain_password str Raw password given by the user. required hashed_password str Hashed password given by get_password_hash required Returns: Name Type Description bool bool Verification status Source code in samudra/core/auth/pengguna.py 25 26 27 28 29 30 31 32 33 34 35 def verify_password ( plain_password : str , hashed_password : str ) -> bool : \"\"\"Verify that the password is correct Args: plain_password (str): Raw password given by the user. hashed_password (str): Hashed password given by [`get_password_hash`][samudra.core.auth.pengguna.get_password_hash] Returns: bool: Verification status \"\"\" return pwd_context . verify ( plain_password , hashed_password )","title":"verify_password()"},{"location":"reference/core/crud/","text":"Functions that relates to Create, Read, Update, Delete of a model. lemma konsep cakupan kata_asing golongan_kata","title":"Index"},{"location":"reference/core/crud/cakupan/","text":"","title":"Cakupan"},{"location":"reference/core/crud/golongan_kata/","text":"","title":"Golongan kata"},{"location":"reference/core/crud/kata_asing/","text":"","title":"Kata asing"},{"location":"reference/core/crud/konsep/","text":"","title":"Konsep"},{"location":"reference/core/crud/lemma/","text":"","title":"Lemma"},{"location":"reference/models/","text":"Module that contains SQL Tables known as models. \ud83c\udfe0 Base \ud83d\udca1 Core \ud83d\udd10 Auth \ud83e\uddea Experimental create_tables ( database , auth = True , experimental = False ) Create tables based on selected criteria Parameters: Name Type Description Default database peewee . Database The database engine to bind the models required auth bool Whether to include auth tables or not. Defaults to True True foreign_lang bool Whether to include foreign lang tables or not. Defaults to True required experimental bool Whether to include experimental tables or not. Defaults to False False Returns: Type Description List [ str ] List of tables created Source code in samudra/models/__init__.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def create_tables ( database : peewee . Database , auth : bool = True , experimental : bool = False , ) -> List [ str ]: \"\"\"Create tables based on selected criteria Args: database (peewee.Database): The database engine to bind the models auth (bool, optional): Whether to include auth tables or not. Defaults to True foreign_lang (bool, optional): Whether to include foreign lang tables or not. Defaults to True experimental (bool, optional): Whether to include experimental tables or not. Defaults to False Returns: List of tables created \"\"\" tables = bind_to_database ( database , auth , experimental ) database . create_tables ( tables ) # TODO logging return database . get_tables ()","title":"Model"},{"location":"reference/models/#samudra.models.create_tables","text":"Create tables based on selected criteria Parameters: Name Type Description Default database peewee . Database The database engine to bind the models required auth bool Whether to include auth tables or not. Defaults to True True foreign_lang bool Whether to include foreign lang tables or not. Defaults to True required experimental bool Whether to include experimental tables or not. Defaults to False False Returns: Type Description List [ str ] List of tables created Source code in samudra/models/__init__.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def create_tables ( database : peewee . Database , auth : bool = True , experimental : bool = False , ) -> List [ str ]: \"\"\"Create tables based on selected criteria Args: database (peewee.Database): The database engine to bind the models auth (bool, optional): Whether to include auth tables or not. Defaults to True foreign_lang (bool, optional): Whether to include foreign lang tables or not. Defaults to True experimental (bool, optional): Whether to include experimental tables or not. Defaults to False Returns: List of tables created \"\"\" tables = bind_to_database ( database , auth , experimental ) database . create_tables ( tables ) # TODO logging return database . get_tables ()","title":"create_tables()"},{"location":"reference/models/base/","text":"File that contains Base Models that is to be inherited by all models. The four bases currently available: BaseDataTable BaseRelationshipTable BaseAttachmentDataTable BaseStrictDataTable BaseAttachmentDataTable Bases: BaseDataTable Model to hold attachment data that has a many-to-many relationship with the primary data. Source code in samudra/models/base.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class BaseAttachmentDataTable ( BaseDataTable ): \"\"\"Model to hold attachment data that has a many-to-many relationship with the primary data.\"\"\" \"The [`BaseRelationshipTable`] that holds the relationship with the primary data.\" @classmethod def connects_to ( cls , other : BaseDataTable , through : BaseRelationshipTable ) -> None : \"\"\"Create a dict that defines connection with [data][samudra.models.base.BaseDataTable] and its [relationship table][samudra.models.base.BaseAttachmentDataTable] Args: other (BaseDataTable): The data to attach the connection through (BaseRelationshipTable): The bridge that holds the many-to-many connections \"\"\" cls . connection_table : Dict [ str , BaseRelationshipTable ] = defaultdict ( BaseRelationshipTable ) cls . connection_table [ other . _meta . table_name ] = through @classmethod def __attach__ ( cls , other : BaseDataTable , values : List [ Dict [ str , str ]] ) -> pw . ModelSelect : \"\"\"A custom dunder method to attach a single row of attachment data to the primary data. Is expected to use when a `other.attach(cls, *args, *kwargs)` method is called. Args: other (BaseDataTable): An instance of the primary data. values (List[Dict[field, value]]): A field:value pair related to this class. Raises: AttributeError: Raised when the connection table is not set. Returns: pw.ModelSelect: A list of rows of this table associated with `other`. \"\"\" rows = [ cls . get_or_create ( ** value )[ 0 ] for value in values ] for row in rows : try : cls . connection_table [ other . _meta . table_name ] . get_or_create ( ** { cls . _meta . table_name : row . id , other . _meta . table_name : other . id } ) except AttributeError : raise AttributeError ( f \" { cls } has no associated connection table\" ) except KeyError : raise KeyError ( f \" { cls } has not defined a connection with { other } \" ) return getattr ( other , cls . _meta . table_name ) @classmethod def with_dependencies ( cls ) -> Tuple [ Type [ BaseDataTable ], ... ]: \"\"\"List itself and dependencies tables.\"\"\" # TODO Add ways to programmatically define dependencies return cls , * cls . connection_table . values () __attach__ ( other , values ) classmethod A custom dunder method to attach a single row of attachment data to the primary data. Is expected to use when a other.attach(cls, *args, *kwargs) method is called. Parameters: Name Type Description Default other BaseDataTable An instance of the primary data. required values List [ Dict [ field , value ]] A field:value pair related to this class. required Raises: Type Description AttributeError Raised when the connection table is not set. Returns: Type Description pw . ModelSelect pw.ModelSelect: A list of rows of this table associated with other . Source code in samudra/models/base.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @classmethod def __attach__ ( cls , other : BaseDataTable , values : List [ Dict [ str , str ]] ) -> pw . ModelSelect : \"\"\"A custom dunder method to attach a single row of attachment data to the primary data. Is expected to use when a `other.attach(cls, *args, *kwargs)` method is called. Args: other (BaseDataTable): An instance of the primary data. values (List[Dict[field, value]]): A field:value pair related to this class. Raises: AttributeError: Raised when the connection table is not set. Returns: pw.ModelSelect: A list of rows of this table associated with `other`. \"\"\" rows = [ cls . get_or_create ( ** value )[ 0 ] for value in values ] for row in rows : try : cls . connection_table [ other . _meta . table_name ] . get_or_create ( ** { cls . _meta . table_name : row . id , other . _meta . table_name : other . id } ) except AttributeError : raise AttributeError ( f \" { cls } has no associated connection table\" ) except KeyError : raise KeyError ( f \" { cls } has not defined a connection with { other } \" ) return getattr ( other , cls . _meta . table_name ) connects_to ( other , through ) classmethod Create a dict that defines connection with data and its relationship table Parameters: Name Type Description Default other BaseDataTable The data to attach the connection required through BaseRelationshipTable The bridge that holds the many-to-many connections required Source code in samudra/models/base.py 55 56 57 58 59 60 61 62 63 64 65 66 @classmethod def connects_to ( cls , other : BaseDataTable , through : BaseRelationshipTable ) -> None : \"\"\"Create a dict that defines connection with [data][samudra.models.base.BaseDataTable] and its [relationship table][samudra.models.base.BaseAttachmentDataTable] Args: other (BaseDataTable): The data to attach the connection through (BaseRelationshipTable): The bridge that holds the many-to-many connections \"\"\" cls . connection_table : Dict [ str , BaseRelationshipTable ] = defaultdict ( BaseRelationshipTable ) cls . connection_table [ other . _meta . table_name ] = through with_dependencies () classmethod List itself and dependencies tables. Source code in samudra/models/base.py 97 98 99 100 101 @classmethod def with_dependencies ( cls ) -> Tuple [ Type [ BaseDataTable ], ... ]: \"\"\"List itself and dependencies tables.\"\"\" # TODO Add ways to programmatically define dependencies return cls , * cls . connection_table . values () BaseDataTable Bases: pw . Model The simplest type of data model. All other models derive from this model including other base models. Fields id (AutoField): the unique id of the data primary_key: True tarikh_masuk (TimestampField): the time it enters the database Meta Meta is subclass of BaseDataTable to hold metadata Attr(Meta) legacy_table_names (bool): The naming scheme of models in SQL Tables. Set to False , so that CamelCase model classnames are converted into camel_case table names in the database. (If set to True , CamelCase \u27a1 camelcase ) Source code in samudra/models/base.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class BaseDataTable ( pw . Model ): \"\"\"The simplest type of data model. All other models derive from this model including other base models. ## Fields - `id` (AutoField): the unique id of the data * primary_key: True - `tarikh_masuk` (TimestampField): the time it enters the database ## Meta Meta is subclass of [`BaseDataTable`][samudra.models.base.BaseDataTable] to hold metadata ### Attr(Meta) - `legacy_table_names` (bool): The naming scheme of models in SQL Tables. Set to `False`, so that `CamelCase` model classnames are converted into `camel_case` table names in the database. (If set to `True`,`CamelCase` \u27a1 `camelcase`) \"\"\" id = pw . AutoField ( primary_key = True ) tarikh_masuk = pw . TimestampField () class Meta : legacy_table_names = False BaseRelationshipTable Bases: BaseDataTable Model to hold many-to-many relationships. Model classes are named ModelAXModelB where ModelA is any BaseAttachmentDataTable and ModelB is any BaseDataTable . Source code in samudra/models/base.py 42 43 44 45 46 47 class BaseRelationshipTable ( BaseDataTable ): \"\"\"Model to hold many-to-many relationships. Model classes are named `ModelAXModelB` where `ModelA` is any [`BaseAttachmentDataTable`][samudra.models.base.BaseAttachmentDataTable] and `ModelB` is any [`BaseDataTable`][samudra.models.base.BaseDataTable]. \"\"\" BaseStrictDataTable Bases: BaseDataTable Model to hold finitely defined data. Source code in samudra/models/base.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 class BaseStrictDataTable ( BaseDataTable ): \"\"\"Model to hold finitely defined data.\"\"\" @classmethod def get_or_create ( cls , * args , ** kwargs ) -> None : \"\"\"Overrides the default `cls.get_or_create()` method to render it unusable. A finitely defined data must be explicitly defined. Raises: AttributeError: This method should not be used. \"\"\" raise AttributeError ( f \" { cls } is a strict table. Rows can only be created explicitly by the `Model.create` method.\" ) get_or_create ( * args , ** kwargs ) classmethod Overrides the default cls.get_or_create() method to render it unusable. A finitely defined data must be explicitly defined. Raises: Type Description AttributeError This method should not be used. Source code in samudra/models/base.py 107 108 109 110 111 112 113 114 115 116 117 @classmethod def get_or_create ( cls , * args , ** kwargs ) -> None : \"\"\"Overrides the default `cls.get_or_create()` method to render it unusable. A finitely defined data must be explicitly defined. Raises: AttributeError: This method should not be used. \"\"\" raise AttributeError ( f \" { cls } is a strict table. Rows can only be created explicitly by the `Model.create` method.\" )","title":"Base"},{"location":"reference/models/base/#samudra.models.base.BaseAttachmentDataTable","text":"Bases: BaseDataTable Model to hold attachment data that has a many-to-many relationship with the primary data. Source code in samudra/models/base.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class BaseAttachmentDataTable ( BaseDataTable ): \"\"\"Model to hold attachment data that has a many-to-many relationship with the primary data.\"\"\" \"The [`BaseRelationshipTable`] that holds the relationship with the primary data.\" @classmethod def connects_to ( cls , other : BaseDataTable , through : BaseRelationshipTable ) -> None : \"\"\"Create a dict that defines connection with [data][samudra.models.base.BaseDataTable] and its [relationship table][samudra.models.base.BaseAttachmentDataTable] Args: other (BaseDataTable): The data to attach the connection through (BaseRelationshipTable): The bridge that holds the many-to-many connections \"\"\" cls . connection_table : Dict [ str , BaseRelationshipTable ] = defaultdict ( BaseRelationshipTable ) cls . connection_table [ other . _meta . table_name ] = through @classmethod def __attach__ ( cls , other : BaseDataTable , values : List [ Dict [ str , str ]] ) -> pw . ModelSelect : \"\"\"A custom dunder method to attach a single row of attachment data to the primary data. Is expected to use when a `other.attach(cls, *args, *kwargs)` method is called. Args: other (BaseDataTable): An instance of the primary data. values (List[Dict[field, value]]): A field:value pair related to this class. Raises: AttributeError: Raised when the connection table is not set. Returns: pw.ModelSelect: A list of rows of this table associated with `other`. \"\"\" rows = [ cls . get_or_create ( ** value )[ 0 ] for value in values ] for row in rows : try : cls . connection_table [ other . _meta . table_name ] . get_or_create ( ** { cls . _meta . table_name : row . id , other . _meta . table_name : other . id } ) except AttributeError : raise AttributeError ( f \" { cls } has no associated connection table\" ) except KeyError : raise KeyError ( f \" { cls } has not defined a connection with { other } \" ) return getattr ( other , cls . _meta . table_name ) @classmethod def with_dependencies ( cls ) -> Tuple [ Type [ BaseDataTable ], ... ]: \"\"\"List itself and dependencies tables.\"\"\" # TODO Add ways to programmatically define dependencies return cls , * cls . connection_table . values ()","title":"BaseAttachmentDataTable"},{"location":"reference/models/base/#samudra.models.base.BaseAttachmentDataTable.__attach__","text":"A custom dunder method to attach a single row of attachment data to the primary data. Is expected to use when a other.attach(cls, *args, *kwargs) method is called. Parameters: Name Type Description Default other BaseDataTable An instance of the primary data. required values List [ Dict [ field , value ]] A field:value pair related to this class. required Raises: Type Description AttributeError Raised when the connection table is not set. Returns: Type Description pw . ModelSelect pw.ModelSelect: A list of rows of this table associated with other . Source code in samudra/models/base.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @classmethod def __attach__ ( cls , other : BaseDataTable , values : List [ Dict [ str , str ]] ) -> pw . ModelSelect : \"\"\"A custom dunder method to attach a single row of attachment data to the primary data. Is expected to use when a `other.attach(cls, *args, *kwargs)` method is called. Args: other (BaseDataTable): An instance of the primary data. values (List[Dict[field, value]]): A field:value pair related to this class. Raises: AttributeError: Raised when the connection table is not set. Returns: pw.ModelSelect: A list of rows of this table associated with `other`. \"\"\" rows = [ cls . get_or_create ( ** value )[ 0 ] for value in values ] for row in rows : try : cls . connection_table [ other . _meta . table_name ] . get_or_create ( ** { cls . _meta . table_name : row . id , other . _meta . table_name : other . id } ) except AttributeError : raise AttributeError ( f \" { cls } has no associated connection table\" ) except KeyError : raise KeyError ( f \" { cls } has not defined a connection with { other } \" ) return getattr ( other , cls . _meta . table_name )","title":"__attach__()"},{"location":"reference/models/base/#samudra.models.base.BaseAttachmentDataTable.connects_to","text":"Create a dict that defines connection with data and its relationship table Parameters: Name Type Description Default other BaseDataTable The data to attach the connection required through BaseRelationshipTable The bridge that holds the many-to-many connections required Source code in samudra/models/base.py 55 56 57 58 59 60 61 62 63 64 65 66 @classmethod def connects_to ( cls , other : BaseDataTable , through : BaseRelationshipTable ) -> None : \"\"\"Create a dict that defines connection with [data][samudra.models.base.BaseDataTable] and its [relationship table][samudra.models.base.BaseAttachmentDataTable] Args: other (BaseDataTable): The data to attach the connection through (BaseRelationshipTable): The bridge that holds the many-to-many connections \"\"\" cls . connection_table : Dict [ str , BaseRelationshipTable ] = defaultdict ( BaseRelationshipTable ) cls . connection_table [ other . _meta . table_name ] = through","title":"connects_to()"},{"location":"reference/models/base/#samudra.models.base.BaseAttachmentDataTable.with_dependencies","text":"List itself and dependencies tables. Source code in samudra/models/base.py 97 98 99 100 101 @classmethod def with_dependencies ( cls ) -> Tuple [ Type [ BaseDataTable ], ... ]: \"\"\"List itself and dependencies tables.\"\"\" # TODO Add ways to programmatically define dependencies return cls , * cls . connection_table . values ()","title":"with_dependencies()"},{"location":"reference/models/base/#samudra.models.base.BaseDataTable","text":"Bases: pw . Model The simplest type of data model. All other models derive from this model including other base models.","title":"BaseDataTable"},{"location":"reference/models/base/#samudra.models.base.BaseDataTable--fields","text":"id (AutoField): the unique id of the data primary_key: True tarikh_masuk (TimestampField): the time it enters the database","title":"Fields"},{"location":"reference/models/base/#samudra.models.base.BaseDataTable--meta","text":"Meta is subclass of BaseDataTable to hold metadata","title":"Meta"},{"location":"reference/models/base/#samudra.models.base.BaseDataTable--attrmeta","text":"legacy_table_names (bool): The naming scheme of models in SQL Tables. Set to False , so that CamelCase model classnames are converted into camel_case table names in the database. (If set to True , CamelCase \u27a1 camelcase ) Source code in samudra/models/base.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class BaseDataTable ( pw . Model ): \"\"\"The simplest type of data model. All other models derive from this model including other base models. ## Fields - `id` (AutoField): the unique id of the data * primary_key: True - `tarikh_masuk` (TimestampField): the time it enters the database ## Meta Meta is subclass of [`BaseDataTable`][samudra.models.base.BaseDataTable] to hold metadata ### Attr(Meta) - `legacy_table_names` (bool): The naming scheme of models in SQL Tables. Set to `False`, so that `CamelCase` model classnames are converted into `camel_case` table names in the database. (If set to `True`,`CamelCase` \u27a1 `camelcase`) \"\"\" id = pw . AutoField ( primary_key = True ) tarikh_masuk = pw . TimestampField () class Meta : legacy_table_names = False","title":"Attr(Meta)"},{"location":"reference/models/base/#samudra.models.base.BaseRelationshipTable","text":"Bases: BaseDataTable Model to hold many-to-many relationships. Model classes are named ModelAXModelB where ModelA is any BaseAttachmentDataTable and ModelB is any BaseDataTable . Source code in samudra/models/base.py 42 43 44 45 46 47 class BaseRelationshipTable ( BaseDataTable ): \"\"\"Model to hold many-to-many relationships. Model classes are named `ModelAXModelB` where `ModelA` is any [`BaseAttachmentDataTable`][samudra.models.base.BaseAttachmentDataTable] and `ModelB` is any [`BaseDataTable`][samudra.models.base.BaseDataTable]. \"\"\"","title":"BaseRelationshipTable"},{"location":"reference/models/base/#samudra.models.base.BaseStrictDataTable","text":"Bases: BaseDataTable Model to hold finitely defined data. Source code in samudra/models/base.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 class BaseStrictDataTable ( BaseDataTable ): \"\"\"Model to hold finitely defined data.\"\"\" @classmethod def get_or_create ( cls , * args , ** kwargs ) -> None : \"\"\"Overrides the default `cls.get_or_create()` method to render it unusable. A finitely defined data must be explicitly defined. Raises: AttributeError: This method should not be used. \"\"\" raise AttributeError ( f \" { cls } is a strict table. Rows can only be created explicitly by the `Model.create` method.\" )","title":"BaseStrictDataTable"},{"location":"reference/models/base/#samudra.models.base.BaseStrictDataTable.get_or_create","text":"Overrides the default cls.get_or_create() method to render it unusable. A finitely defined data must be explicitly defined. Raises: Type Description AttributeError This method should not be used. Source code in samudra/models/base.py 107 108 109 110 111 112 113 114 115 116 117 @classmethod def get_or_create ( cls , * args , ** kwargs ) -> None : \"\"\"Overrides the default `cls.get_or_create()` method to render it unusable. A finitely defined data must be explicitly defined. Raises: AttributeError: This method should not be used. \"\"\" raise AttributeError ( f \" { cls } is a strict table. Rows can only be created explicitly by the `Model.create` method.\" )","title":"get_or_create()"},{"location":"reference/models/auth/","text":"Module containing models necessary for user authentication. /pengguna","title":"Index"},{"location":"reference/models/auth/pengguna/","text":"Keizinan Bases: BaseStrictDataTable Role model for controlling access types Fields peranan (TextField): name of role null: False unique: True tambah (BooleanField): can create null: False baca (BooleanField): can read null: False ubah (BooleanField): can update null: False buang (BooleanField): can delete null: False Source code in samudra/models/auth/pengguna.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Keizinan ( BaseStrictDataTable ): \"\"\"Role model for controlling access types ## Fields - `peranan` (TextField): name of role * null: False * unique: True - `tambah` (BooleanField): can create * null: False - `baca` (BooleanField): can read * null: False - `ubah` (BooleanField): can update * null: False - `buang` (BooleanField): can delete * null: False \"\"\" peranan = TextField ( null = False , unique = True ) tambah = BooleanField ( null = False ) baca = BooleanField ( null = False ) ubah = BooleanField ( null = False ) buang = BooleanField ( null = False ) Pengguna Bases: BaseDataTable User model to store users. Fields nama (TextField): username null: False kunci (TextField): hashed password null: False peranan (ForeignKeyField): foreign key to Keizinan field: Keizinan.peranan backref: Keizinan.pengguna on delete: set default default: RoleEnum.DEFAULT Source code in samudra/models/auth/pengguna.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class Pengguna ( BaseDataTable ): \"\"\"User model to store users. ## Fields - `nama` (TextField): username * null: False - `kunci` (TextField): hashed password * null: False - `peranan` (ForeignKeyField): foreign key to [`Keizinan`][samudra.models.auth.pengguna.Keizinan] * field: Keizinan.peranan * backref: Keizinan.pengguna * on delete: set default * default: [`RoleEnum.DEFAULT`][samudra.model.auth.pengguna.RoleEnum] \"\"\" nama = TextField ( null = False ) kunci = TextField ( null = False ) peranan = ForeignKeyField ( model = Keizinan , field = Keizinan . peranan , backref = \"pengguna\" , on_delete = \"set default\" , default = RoleEnum . DEFAULT . value , ) def __repr__ ( self ) -> str : return f \"<model. { self . __class__ . __name__ } : id= { self . id } nama= { self . nama } kunci= { self . kunci } >\" RoleEnum Bases: enum . Enum List of Roles Values DEFAULT = 'BIASA' ADMIN = 'ADMIN' Source code in samudra/models/auth/pengguna.py 8 9 10 11 12 13 14 15 16 17 class RoleEnum ( enum . Enum ): \"\"\"List of Roles ## Values - `DEFAULT` = 'BIASA' - `ADMIN` = 'ADMIN' \"\"\" DEFAULT = \"BIASA\" ADMIN = \"ADMIN\"","title":"Pengguna"},{"location":"reference/models/auth/pengguna/#samudra.models.auth.pengguna.Keizinan","text":"Bases: BaseStrictDataTable Role model for controlling access types","title":"Keizinan"},{"location":"reference/models/auth/pengguna/#samudra.models.auth.pengguna.Keizinan--fields","text":"peranan (TextField): name of role null: False unique: True tambah (BooleanField): can create null: False baca (BooleanField): can read null: False ubah (BooleanField): can update null: False buang (BooleanField): can delete null: False Source code in samudra/models/auth/pengguna.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Keizinan ( BaseStrictDataTable ): \"\"\"Role model for controlling access types ## Fields - `peranan` (TextField): name of role * null: False * unique: True - `tambah` (BooleanField): can create * null: False - `baca` (BooleanField): can read * null: False - `ubah` (BooleanField): can update * null: False - `buang` (BooleanField): can delete * null: False \"\"\" peranan = TextField ( null = False , unique = True ) tambah = BooleanField ( null = False ) baca = BooleanField ( null = False ) ubah = BooleanField ( null = False ) buang = BooleanField ( null = False )","title":"Fields"},{"location":"reference/models/auth/pengguna/#samudra.models.auth.pengguna.Pengguna","text":"Bases: BaseDataTable User model to store users.","title":"Pengguna"},{"location":"reference/models/auth/pengguna/#samudra.models.auth.pengguna.Pengguna--fields","text":"nama (TextField): username null: False kunci (TextField): hashed password null: False peranan (ForeignKeyField): foreign key to Keizinan field: Keizinan.peranan backref: Keizinan.pengguna on delete: set default default: RoleEnum.DEFAULT Source code in samudra/models/auth/pengguna.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class Pengguna ( BaseDataTable ): \"\"\"User model to store users. ## Fields - `nama` (TextField): username * null: False - `kunci` (TextField): hashed password * null: False - `peranan` (ForeignKeyField): foreign key to [`Keizinan`][samudra.models.auth.pengguna.Keizinan] * field: Keizinan.peranan * backref: Keizinan.pengguna * on delete: set default * default: [`RoleEnum.DEFAULT`][samudra.model.auth.pengguna.RoleEnum] \"\"\" nama = TextField ( null = False ) kunci = TextField ( null = False ) peranan = ForeignKeyField ( model = Keizinan , field = Keizinan . peranan , backref = \"pengguna\" , on_delete = \"set default\" , default = RoleEnum . DEFAULT . value , ) def __repr__ ( self ) -> str : return f \"<model. { self . __class__ . __name__ } : id= { self . id } nama= { self . nama } kunci= { self . kunci } >\"","title":"Fields"},{"location":"reference/models/auth/pengguna/#samudra.models.auth.pengguna.RoleEnum","text":"Bases: enum . Enum List of Roles","title":"RoleEnum"},{"location":"reference/models/auth/pengguna/#samudra.models.auth.pengguna.RoleEnum--values","text":"DEFAULT = 'BIASA' ADMIN = 'ADMIN' Source code in samudra/models/auth/pengguna.py 8 9 10 11 12 13 14 15 16 17 class RoleEnum ( enum . Enum ): \"\"\"List of Roles ## Values - `DEFAULT` = 'BIASA' - `ADMIN` = 'ADMIN' \"\"\" DEFAULT = \"BIASA\" ADMIN = \"ADMIN\"","title":"Values"},{"location":"reference/models/core/","text":"Submodules that contains core models necessary to represent linguistic data. Lemma Konsep Kata_Asing Cakupan","title":"Index"},{"location":"reference/models/core/cakupan/","text":"Cakupan Bases: BaseAttachmentDataTable Context model to attach to meaning from Konsep via CakupanXKonsep . Fields nama (TextField): the context name null: False unique: True keterangan (TextField): the description of the context null: True Attrs connection_table ( BaseRelationshipTable ): CakupanXKonsep Source code in samudra/models/core/cakupan.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Cakupan ( BaseAttachmentDataTable ): \"\"\"Context model to attach to meaning from [`Konsep`][samudra.models.core.konsep.Konsep] via [`CakupanXKonsep`][samudra.models.core.cakupan.CakupanXKonsep]. ## Fields - `nama` (TextField): the context name * null: False * unique: True - `keterangan` (TextField): the description of the context * null: True ## Attrs - `connection_table` ([`BaseRelationshipTable`][samudra.models.base.BaseRelationshipTable]): [`CakupanXKonsep`][samudra.models.core.cakupan.CakupanXKonsep] \"\"\" nama = TextField ( null = False , unique = True ) keterangan = TextField ( null = True ) CakupanXKonsep Bases: BaseRelationshipTable A many-to-many relationship between Cakupan and Konsep . Fields cakupan (ForeignKeyField): foreign key to Cakupan . field: Cakupan.id backref: Cakupan.konsep on delete: cascade konsep (ForeignKeyField): foreign key to konsep . field: Konsep.id backref: Konsep.cakupan on delete: cascade Source code in samudra/models/core/cakupan.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class CakupanXKonsep ( BaseRelationshipTable ): \"\"\"A many-to-many relationship between [`Cakupan`][samudra.models.core.cakupan.Cakupan] and [`Konsep`][samudra.models.core.konsep.Konsep]. ## Fields - `cakupan` (ForeignKeyField): foreign key to [`Cakupan`][samudra.models.core.cakupan.Cakupan]. * field: `Cakupan.id` * backref: `Cakupan.konsep` * on delete: cascade - `konsep` (ForeignKeyField): foreign key to [`konsep`][samudra.models.core.konsep.Konsep]. * field: `Konsep.id` * backref: `Konsep.cakupan` * on delete: cascade \"\"\" cakupan = ForeignKeyField ( model = Cakupan , field = Cakupan . id , backref = \"konsep\" , on_delete = \"cascade\" ) konsep = ForeignKeyField ( model = Konsep , field = Konsep . id , backref = \"cakupan\" , on_delete = \"cascade\" )","title":"Cakupan"},{"location":"reference/models/core/cakupan/#samudra.models.core.cakupan.Cakupan","text":"Bases: BaseAttachmentDataTable Context model to attach to meaning from Konsep via CakupanXKonsep .","title":"Cakupan"},{"location":"reference/models/core/cakupan/#samudra.models.core.cakupan.Cakupan--fields","text":"nama (TextField): the context name null: False unique: True keterangan (TextField): the description of the context null: True","title":"Fields"},{"location":"reference/models/core/cakupan/#samudra.models.core.cakupan.Cakupan--attrs","text":"connection_table ( BaseRelationshipTable ): CakupanXKonsep Source code in samudra/models/core/cakupan.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Cakupan ( BaseAttachmentDataTable ): \"\"\"Context model to attach to meaning from [`Konsep`][samudra.models.core.konsep.Konsep] via [`CakupanXKonsep`][samudra.models.core.cakupan.CakupanXKonsep]. ## Fields - `nama` (TextField): the context name * null: False * unique: True - `keterangan` (TextField): the description of the context * null: True ## Attrs - `connection_table` ([`BaseRelationshipTable`][samudra.models.base.BaseRelationshipTable]): [`CakupanXKonsep`][samudra.models.core.cakupan.CakupanXKonsep] \"\"\" nama = TextField ( null = False , unique = True ) keterangan = TextField ( null = True )","title":"Attrs"},{"location":"reference/models/core/cakupan/#samudra.models.core.cakupan.CakupanXKonsep","text":"Bases: BaseRelationshipTable A many-to-many relationship between Cakupan and Konsep .","title":"CakupanXKonsep"},{"location":"reference/models/core/cakupan/#samudra.models.core.cakupan.CakupanXKonsep--fields","text":"cakupan (ForeignKeyField): foreign key to Cakupan . field: Cakupan.id backref: Cakupan.konsep on delete: cascade konsep (ForeignKeyField): foreign key to konsep . field: Konsep.id backref: Konsep.cakupan on delete: cascade Source code in samudra/models/core/cakupan.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class CakupanXKonsep ( BaseRelationshipTable ): \"\"\"A many-to-many relationship between [`Cakupan`][samudra.models.core.cakupan.Cakupan] and [`Konsep`][samudra.models.core.konsep.Konsep]. ## Fields - `cakupan` (ForeignKeyField): foreign key to [`Cakupan`][samudra.models.core.cakupan.Cakupan]. * field: `Cakupan.id` * backref: `Cakupan.konsep` * on delete: cascade - `konsep` (ForeignKeyField): foreign key to [`konsep`][samudra.models.core.konsep.Konsep]. * field: `Konsep.id` * backref: `Konsep.cakupan` * on delete: cascade \"\"\" cakupan = ForeignKeyField ( model = Cakupan , field = Cakupan . id , backref = \"konsep\" , on_delete = \"cascade\" ) konsep = ForeignKeyField ( model = Konsep , field = Konsep . id , backref = \"cakupan\" , on_delete = \"cascade\" )","title":"Fields"},{"location":"reference/models/core/kata_asing/","text":"KataAsing Bases: BaseAttachmentDataTable Foreign Word model to attach to meaning from Konsep via KataAsingXKonsep . Field nama (TextField): the word null: False bahasa (TextField): the language the word belongs to Attr connection_table ( BaseRelationshipTable ) = KataAsingXKonsep Source code in samudra/models/core/kata_asing.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class KataAsing ( BaseAttachmentDataTable ): \"\"\"Foreign Word model to attach to meaning from [`Konsep`][samudra.models.core.konsep.Konsep] via [`KataAsingXKonsep`][samudra.models.core.kata_asing.KataAsingXKonsep]. ## Field - `nama` (TextField): the word * null: False - `bahasa` (TextField): the language the word belongs to ## Attr - `connection_table` ([`BaseRelationshipTable`][samudra.models.base.BaseRelationshipTable]) = [`KataAsingXKonsep`][samudra.models.core.kata_asing.KataAsingXKonsep] \"\"\" nama = TextField ( null = False ) bahasa = TextField ( null = False ) KataAsingXKonsep Bases: BaseRelationshipTable A many-to-many relationship between KataAsing and Konsep . Fields KataAsing (ForeignKeyField): foreign key to KataAsing . field: KataAsing.id backref: KataAsing.konsep on delete: cascade konsep (ForeignKeyField): foreign key to konsep . field: Konsep.id backref: Konsep.kata_asing on delete: cascade Source code in samudra/models/core/kata_asing.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class KataAsingXKonsep ( BaseRelationshipTable ): \"\"\"A many-to-many relationship between [`KataAsing`][samudra.models.core.kata_asing.KataAsing] and [`Konsep`][samudra.models.core.konsep.Konsep]. ## Fields - `KataAsing` (ForeignKeyField): foreign key to [`KataAsing`][samudra.models.core.kata_asing.KataAsing]. * field: `KataAsing.id` * backref: `KataAsing.konsep` * on delete: cascade - `konsep` (ForeignKeyField): foreign key to [`konsep`][samudra.models.core.konsep.Konsep]. * field: `Konsep.id` * backref: `Konsep.kata_asing` * on delete: cascade \"\"\" kata_asing = ForeignKeyField ( KataAsing , field = KataAsing . id , backref = \"konsep\" , on_delete = \"cascade\" ) konsep = ForeignKeyField ( Konsep , field = Konsep . id , backref = \"kata_asing\" , on_delete = \"cascade\" )","title":"Kata asing"},{"location":"reference/models/core/kata_asing/#samudra.models.core.kata_asing.KataAsing","text":"Bases: BaseAttachmentDataTable Foreign Word model to attach to meaning from Konsep via KataAsingXKonsep .","title":"KataAsing"},{"location":"reference/models/core/kata_asing/#samudra.models.core.kata_asing.KataAsing--field","text":"nama (TextField): the word null: False bahasa (TextField): the language the word belongs to","title":"Field"},{"location":"reference/models/core/kata_asing/#samudra.models.core.kata_asing.KataAsing--attr","text":"connection_table ( BaseRelationshipTable ) = KataAsingXKonsep Source code in samudra/models/core/kata_asing.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class KataAsing ( BaseAttachmentDataTable ): \"\"\"Foreign Word model to attach to meaning from [`Konsep`][samudra.models.core.konsep.Konsep] via [`KataAsingXKonsep`][samudra.models.core.kata_asing.KataAsingXKonsep]. ## Field - `nama` (TextField): the word * null: False - `bahasa` (TextField): the language the word belongs to ## Attr - `connection_table` ([`BaseRelationshipTable`][samudra.models.base.BaseRelationshipTable]) = [`KataAsingXKonsep`][samudra.models.core.kata_asing.KataAsingXKonsep] \"\"\" nama = TextField ( null = False ) bahasa = TextField ( null = False )","title":"Attr"},{"location":"reference/models/core/kata_asing/#samudra.models.core.kata_asing.KataAsingXKonsep","text":"Bases: BaseRelationshipTable A many-to-many relationship between KataAsing and Konsep .","title":"KataAsingXKonsep"},{"location":"reference/models/core/kata_asing/#samudra.models.core.kata_asing.KataAsingXKonsep--fields","text":"KataAsing (ForeignKeyField): foreign key to KataAsing . field: KataAsing.id backref: KataAsing.konsep on delete: cascade konsep (ForeignKeyField): foreign key to konsep . field: Konsep.id backref: Konsep.kata_asing on delete: cascade Source code in samudra/models/core/kata_asing.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class KataAsingXKonsep ( BaseRelationshipTable ): \"\"\"A many-to-many relationship between [`KataAsing`][samudra.models.core.kata_asing.KataAsing] and [`Konsep`][samudra.models.core.konsep.Konsep]. ## Fields - `KataAsing` (ForeignKeyField): foreign key to [`KataAsing`][samudra.models.core.kata_asing.KataAsing]. * field: `KataAsing.id` * backref: `KataAsing.konsep` * on delete: cascade - `konsep` (ForeignKeyField): foreign key to [`konsep`][samudra.models.core.konsep.Konsep]. * field: `Konsep.id` * backref: `Konsep.kata_asing` * on delete: cascade \"\"\" kata_asing = ForeignKeyField ( KataAsing , field = KataAsing . id , backref = \"konsep\" , on_delete = \"cascade\" ) konsep = ForeignKeyField ( Konsep , field = Konsep . id , backref = \"kata_asing\" , on_delete = \"cascade\" )","title":"Fields"},{"location":"reference/models/core/konsep/","text":"GolonganKata Bases: BaseStrictDataTable Word Class model such as nouns, verbs, etc. Fields: id (CharField): Short Name to identify the Word Class max length: 6 unique: True null: False nama (TextField): Full name keterangan (TextField): Description of word class Source code in samudra/models/core/konsep.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class GolonganKata ( BaseStrictDataTable ): \"\"\"Word Class model such as nouns, verbs, etc. ## Fields: - `id` (CharField): Short Name to identify the Word Class * max length: 6 * unique: True * null: False - `nama` (TextField): Full name - `keterangan` (TextField): Description of word class \"\"\" id = CharField ( max_length = 6 , unique = True , null = False ) nama = TextField ( null = False ) keterangan = TextField ( null = False ) def __repr__ ( self ): return f \"<models.GolonganKata id= { self . id } nama=' { self . nama } ' keterangan=' { self . keterangan } '>\" Konsep Bases: BaseDataTable Concept model to list the meanings of words from Lemma . Fields lemma (ForeignKeyField): foreign key to Lemma . field: Lemma.id backref: Lemma.konsep on delete: \"cascade\" golongan (ForeignKeyField): foreign key to GolonganKata . field: GolonganKata.id backref: GolonganKata.konsep on delete: set null null: True keterangan (TextField): the description of meaning. null: True index: True tertib (IntegerField): the order in list of meaning to corresponding Lemma null: True Source code in samudra/models/core/konsep.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class Konsep ( BaseDataTable ): \"\"\"Concept model to list the meanings of words from [`Lemma`][samudra.models.core.lemma.Lemma]. ## Fields - `lemma` (ForeignKeyField): foreign key to [`Lemma`][samudra.models.core.lemma.Lemma]. * field: `Lemma.id` * backref: `Lemma.konsep` * on delete: \"cascade\" - `golongan` (ForeignKeyField): foreign key to [`GolonganKata`][samudra.models.core.konsep.GolonganKata]. * field: `GolonganKata.id` * backref: `GolonganKata.konsep` * on delete: set null * null: True - `keterangan` (TextField): the description of meaning. * null: True * index: True - `tertib` (IntegerField): the order in list of meaning to corresponding [`Lemma`][samudra.models.core.lemma.Lemma] * null: True \"\"\" lemma = ForeignKeyField ( model = Lemma , field = Lemma . id , backref = \"konsep\" , on_delete = \"cascade\" ) # TODO: Create composite key of id and tertib golongan = ForeignKeyField ( model = GolonganKata , field = GolonganKata . id , on_delete = \"set null\" , null = True ) keterangan = TextField ( null = True , index = True ) # --- tertib = IntegerField ( null = True ) def __repr__ ( self ): return f \"<model. { self . __class__ . __name__ } : id= { self . id } lemma= { self . lemma } golongan= { self . golongan } keterangan=' { self . keterangan } '>\" def attach ( self , to_model : BaseAttachmentDataTable , values : List [ Dict [ str , str ]] ) -> ModelSelect : \"\"\"Get or Create attachment from self to `to_model` with the corresponding `values`. Args: to_model (BaseAttachmentDataTable): Attachment data table associated with the value. values (List[Dict[str, str]]): Values to attach to `to_model`. Returns: pw.ModelSelect: List of attachment data associated with self. \"\"\" return to_model . __attach__ ( self , values = values ) attach ( to_model , values ) Get or Create attachment from self to to_model with the corresponding values . Parameters: Name Type Description Default to_model BaseAttachmentDataTable Attachment data table associated with the value. required values List [ Dict [ str , str ]] Values to attach to to_model . required Returns: Type Description ModelSelect pw.ModelSelect: List of attachment data associated with self. Source code in samudra/models/core/konsep.py 77 78 79 80 81 82 83 84 85 86 87 88 89 def attach ( self , to_model : BaseAttachmentDataTable , values : List [ Dict [ str , str ]] ) -> ModelSelect : \"\"\"Get or Create attachment from self to `to_model` with the corresponding `values`. Args: to_model (BaseAttachmentDataTable): Attachment data table associated with the value. values (List[Dict[str, str]]): Values to attach to `to_model`. Returns: pw.ModelSelect: List of attachment data associated with self. \"\"\" return to_model . __attach__ ( self , values = values )","title":"Konsep"},{"location":"reference/models/core/konsep/#samudra.models.core.konsep.GolonganKata","text":"Bases: BaseStrictDataTable Word Class model such as nouns, verbs, etc.","title":"GolonganKata"},{"location":"reference/models/core/konsep/#samudra.models.core.konsep.GolonganKata--fields","text":"id (CharField): Short Name to identify the Word Class max length: 6 unique: True null: False nama (TextField): Full name keterangan (TextField): Description of word class Source code in samudra/models/core/konsep.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class GolonganKata ( BaseStrictDataTable ): \"\"\"Word Class model such as nouns, verbs, etc. ## Fields: - `id` (CharField): Short Name to identify the Word Class * max length: 6 * unique: True * null: False - `nama` (TextField): Full name - `keterangan` (TextField): Description of word class \"\"\" id = CharField ( max_length = 6 , unique = True , null = False ) nama = TextField ( null = False ) keterangan = TextField ( null = False ) def __repr__ ( self ): return f \"<models.GolonganKata id= { self . id } nama=' { self . nama } ' keterangan=' { self . keterangan } '>\"","title":"Fields:"},{"location":"reference/models/core/konsep/#samudra.models.core.konsep.Konsep","text":"Bases: BaseDataTable Concept model to list the meanings of words from Lemma .","title":"Konsep"},{"location":"reference/models/core/konsep/#samudra.models.core.konsep.Konsep--fields","text":"lemma (ForeignKeyField): foreign key to Lemma . field: Lemma.id backref: Lemma.konsep on delete: \"cascade\" golongan (ForeignKeyField): foreign key to GolonganKata . field: GolonganKata.id backref: GolonganKata.konsep on delete: set null null: True keterangan (TextField): the description of meaning. null: True index: True tertib (IntegerField): the order in list of meaning to corresponding Lemma null: True Source code in samudra/models/core/konsep.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class Konsep ( BaseDataTable ): \"\"\"Concept model to list the meanings of words from [`Lemma`][samudra.models.core.lemma.Lemma]. ## Fields - `lemma` (ForeignKeyField): foreign key to [`Lemma`][samudra.models.core.lemma.Lemma]. * field: `Lemma.id` * backref: `Lemma.konsep` * on delete: \"cascade\" - `golongan` (ForeignKeyField): foreign key to [`GolonganKata`][samudra.models.core.konsep.GolonganKata]. * field: `GolonganKata.id` * backref: `GolonganKata.konsep` * on delete: set null * null: True - `keterangan` (TextField): the description of meaning. * null: True * index: True - `tertib` (IntegerField): the order in list of meaning to corresponding [`Lemma`][samudra.models.core.lemma.Lemma] * null: True \"\"\" lemma = ForeignKeyField ( model = Lemma , field = Lemma . id , backref = \"konsep\" , on_delete = \"cascade\" ) # TODO: Create composite key of id and tertib golongan = ForeignKeyField ( model = GolonganKata , field = GolonganKata . id , on_delete = \"set null\" , null = True ) keterangan = TextField ( null = True , index = True ) # --- tertib = IntegerField ( null = True ) def __repr__ ( self ): return f \"<model. { self . __class__ . __name__ } : id= { self . id } lemma= { self . lemma } golongan= { self . golongan } keterangan=' { self . keterangan } '>\" def attach ( self , to_model : BaseAttachmentDataTable , values : List [ Dict [ str , str ]] ) -> ModelSelect : \"\"\"Get or Create attachment from self to `to_model` with the corresponding `values`. Args: to_model (BaseAttachmentDataTable): Attachment data table associated with the value. values (List[Dict[str, str]]): Values to attach to `to_model`. Returns: pw.ModelSelect: List of attachment data associated with self. \"\"\" return to_model . __attach__ ( self , values = values )","title":"Fields"},{"location":"reference/models/core/konsep/#samudra.models.core.konsep.Konsep.attach","text":"Get or Create attachment from self to to_model with the corresponding values . Parameters: Name Type Description Default to_model BaseAttachmentDataTable Attachment data table associated with the value. required values List [ Dict [ str , str ]] Values to attach to to_model . required Returns: Type Description ModelSelect pw.ModelSelect: List of attachment data associated with self. Source code in samudra/models/core/konsep.py 77 78 79 80 81 82 83 84 85 86 87 88 89 def attach ( self , to_model : BaseAttachmentDataTable , values : List [ Dict [ str , str ]] ) -> ModelSelect : \"\"\"Get or Create attachment from self to `to_model` with the corresponding `values`. Args: to_model (BaseAttachmentDataTable): Attachment data table associated with the value. values (List[Dict[str, str]]): Values to attach to `to_model`. Returns: pw.ModelSelect: List of attachment data associated with self. \"\"\" return to_model . __attach__ ( self , values = values )","title":"attach()"},{"location":"reference/models/core/lemma/","text":"Lemma Bases: BaseDataTable Word Entry model such that listed in the dictionary. Fields nama (TextField): the word as displayed on a dictionary. null: False Source code in samudra/models/core/lemma.py 6 7 8 9 10 11 12 13 14 15 16 17 class Lemma ( BaseDataTable ): \"\"\"Word Entry model such that listed in the dictionary. ## Fields - `nama` (TextField): the word as displayed on a dictionary. * null: False \"\"\" nama = TextField ( null = False ) def __repr__ ( self ) -> str : return f \"<model. { self . __class__ . __name__ } : id= { self . id } nama= { self . nama } >\"","title":"Lemma"},{"location":"reference/models/core/lemma/#samudra.models.core.lemma.Lemma","text":"Bases: BaseDataTable Word Entry model such that listed in the dictionary.","title":"Lemma"},{"location":"reference/models/core/lemma/#samudra.models.core.lemma.Lemma--fields","text":"nama (TextField): the word as displayed on a dictionary. null: False Source code in samudra/models/core/lemma.py 6 7 8 9 10 11 12 13 14 15 16 17 class Lemma ( BaseDataTable ): \"\"\"Word Entry model such that listed in the dictionary. ## Fields - `nama` (TextField): the word as displayed on a dictionary. * null: False \"\"\" nama = TextField ( null = False ) def __repr__ ( self ) -> str : return f \"<model. { self . __class__ . __name__ } : id= { self . id } nama= { self . nama } >\"","title":"Fields"},{"location":"reference/models/experimental/","text":"\ud83e\uddea EXPERIMENTAL Models defined here are still experimental /petikan","title":"Index"},{"location":"reference/models/experimental/petikan/","text":"Petikan Bases: BaseAttachmentDataTable \ud83e\uddea EXPERIMENTAL Sentence from sources that used the Lemma in the sense described by Konsep . Source code in samudra/models/experimental/petikan.py 20 21 22 23 24 25 26 27 28 29 30 31 class Petikan ( BaseAttachmentDataTable ): \"\"\"\ud83e\uddea EXPERIMENTAL Sentence from sources that used the [`Lemma`][samudra.models.core.lemma.Lemma] in the sense described by [`Konsep`][samudra.models.core.konsep.Konsep].\"\"\" petikan = TextField ( null = False , index = True ) # --> Pautan ke SumberPetikan sumber = ForeignKeyField ( model = SumberPetikan , field = SumberPetikan . id , backref = \"petikan\" , on_delete = \"set null\" , null = True , ) PetikanXKonsep Bases: BaseRelationshipTable \ud83e\uddea EXPERIMENTAL A many-to-many relationship between Petikan and Konsep . Fields Petikan (ForeignKeyField): foreign key to Petikan . field: Petikan.id backref: Petikan.konsep on delete: cascade konsep (ForeignKeyField): foreign key to Konsep . field: Konsep.id backref: Konsep.petikan on delete: cascade Source code in samudra/models/experimental/petikan.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class PetikanXKonsep ( BaseRelationshipTable ): \"\"\"\ud83e\uddea EXPERIMENTAL A many-to-many relationship between [`Petikan`][samudra.models.experimental.petikan.Petikan] and [`Konsep`][samudra.models.core.konsep.Konsep]. ## Fields - `Petikan` (ForeignKeyField): foreign key to [`Petikan`][samudra.models.experimental.petikan.Petikan]. * field: `Petikan.id` * backref: `Petikan.konsep` * on delete: cascade - `konsep` (ForeignKeyField): foreign key to [`Konsep`][samudra.models.core.konsep.Konsep]. * field: `Konsep.id` * backref: `Konsep.petikan` * on delete: cascade \"\"\" petikan = ForeignKeyField ( model = Petikan , field = Petikan . id , backref = \"konsep\" , on_delete = \"cascade\" ) konsep = ForeignKeyField ( model = Konsep , field = Konsep . id , backref = \"petikan\" , on_delete = \"cascade\" ) SumberPetikan Bases: BaseDataTable \ud83e\uddea EXPERIMENTAL Source of the sentence in Petikan . Source code in samudra/models/experimental/petikan.py 11 12 13 14 15 16 17 class SumberPetikan ( BaseDataTable ): \"\"\"\ud83e\uddea EXPERIMENTAL Source of the sentence in [`Petikan`][samudra.models.experimental.petikan.Petikan].\"\"\" tajuk = TextField ( null = False , index = True ) tarikh = DateField () # ? Aku masih tak tahu macam mana nak uruskan metadata dari pelbagai jenis sumber metadata = TextField ( null = True )","title":"Petikan"},{"location":"reference/models/experimental/petikan/#samudra.models.experimental.petikan.Petikan","text":"Bases: BaseAttachmentDataTable \ud83e\uddea EXPERIMENTAL Sentence from sources that used the Lemma in the sense described by Konsep . Source code in samudra/models/experimental/petikan.py 20 21 22 23 24 25 26 27 28 29 30 31 class Petikan ( BaseAttachmentDataTable ): \"\"\"\ud83e\uddea EXPERIMENTAL Sentence from sources that used the [`Lemma`][samudra.models.core.lemma.Lemma] in the sense described by [`Konsep`][samudra.models.core.konsep.Konsep].\"\"\" petikan = TextField ( null = False , index = True ) # --> Pautan ke SumberPetikan sumber = ForeignKeyField ( model = SumberPetikan , field = SumberPetikan . id , backref = \"petikan\" , on_delete = \"set null\" , null = True , )","title":"Petikan"},{"location":"reference/models/experimental/petikan/#samudra.models.experimental.petikan.PetikanXKonsep","text":"Bases: BaseRelationshipTable \ud83e\uddea EXPERIMENTAL A many-to-many relationship between Petikan and Konsep .","title":"PetikanXKonsep"},{"location":"reference/models/experimental/petikan/#samudra.models.experimental.petikan.PetikanXKonsep--fields","text":"Petikan (ForeignKeyField): foreign key to Petikan . field: Petikan.id backref: Petikan.konsep on delete: cascade konsep (ForeignKeyField): foreign key to Konsep . field: Konsep.id backref: Konsep.petikan on delete: cascade Source code in samudra/models/experimental/petikan.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class PetikanXKonsep ( BaseRelationshipTable ): \"\"\"\ud83e\uddea EXPERIMENTAL A many-to-many relationship between [`Petikan`][samudra.models.experimental.petikan.Petikan] and [`Konsep`][samudra.models.core.konsep.Konsep]. ## Fields - `Petikan` (ForeignKeyField): foreign key to [`Petikan`][samudra.models.experimental.petikan.Petikan]. * field: `Petikan.id` * backref: `Petikan.konsep` * on delete: cascade - `konsep` (ForeignKeyField): foreign key to [`Konsep`][samudra.models.core.konsep.Konsep]. * field: `Konsep.id` * backref: `Konsep.petikan` * on delete: cascade \"\"\" petikan = ForeignKeyField ( model = Petikan , field = Petikan . id , backref = \"konsep\" , on_delete = \"cascade\" ) konsep = ForeignKeyField ( model = Konsep , field = Konsep . id , backref = \"petikan\" , on_delete = \"cascade\" )","title":"Fields"},{"location":"reference/models/experimental/petikan/#samudra.models.experimental.petikan.SumberPetikan","text":"Bases: BaseDataTable \ud83e\uddea EXPERIMENTAL Source of the sentence in Petikan . Source code in samudra/models/experimental/petikan.py 11 12 13 14 15 16 17 class SumberPetikan ( BaseDataTable ): \"\"\"\ud83e\uddea EXPERIMENTAL Source of the sentence in [`Petikan`][samudra.models.experimental.petikan.Petikan].\"\"\" tajuk = TextField ( null = False , index = True ) tarikh = DateField () # ? Aku masih tak tahu macam mana nak uruskan metadata dari pelbagai jenis sumber metadata = TextField ( null = True )","title":"SumberPetikan"},{"location":"reference/schemas/","text":"Schema to structure data within application. Warning This schema is still a mess. I hope to reorganize it one day. As such, I put off documenting it now as I prioritize other docs.","title":"Schema"},{"location":"reference/schemas/input/","text":"","title":"Index"},{"location":"reference/schemas/input/accepted_fields/","text":"","title":"Accepted fields"},{"location":"reference/schemas/input/annotated_text/","text":"AnnotatedText Bases: pyd . BaseModel Uses regex to annotate text Example body \"This is a string #tag_1 #tag-2 {lang.en:new} {meta.gol:nama}\" Source code in samudra/schemas/input/annotated_text.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class AnnotatedText ( pyd . BaseModel ): \"\"\"Uses regex to annotate text Example body: \"This is a string #tag_1 #tag-2 {lang.en:new} {meta.gol:nama}\" \"\"\" body : str @property def _tokens ( self ) -> Dict [ str , Union [ list , str ]]: to_return = defaultdict ( list ) for match in re . finditer ( REGEX_PATTERN , self . body ): if match . lastgroup : to_return [ match . lastgroup ] . append ( match [ 0 ]) if len ( to_return [ \"content\" ]) > 1 : raise SyntaxError ( { \"message\" : \"Returns {} texts. Expects 1. Unexpected character(s) causes the text to be parsed incorrectly.\" . format ( len ( to_return ) ), \"content\" : \"<?> \" . join ( to_return [ \"content\" ]), \"body\" : self . body , \"tags\" : to_return . get ( \"tag\" ), \"fields\" : to_return . get ( \"field\" ), } ) to_return [ \"content\" ]: str = to_return [ \"content\" ][ 0 ] . strip () return to_return @property def fields ( self ) -> dict : to_eval : Optional [ str ] = self . _tokens . get ( \"field\" , None ) to_return = defaultdict ( dict ) for eval_str in to_eval : key , value = eval_str . strip ( \"{\" ) . strip ( \"}\" ) . split ( \":\" ) key_1 , key_2 = key . split ( \".\" ) if key_1 not in AcceptedFields . __members__ : raise SyntaxError ( f \"Field ' { key_1 } ' not expected. Only { AcceptedFields . __members__ } are expected.\" ) elif key_2 not in AcceptedFields [ key_1 ] . value : raise SyntaxError ( f \"Field ' { key_2 } ' not expected. Only { AcceptedFields [ key_1 ] . value } are expected.\" ) if AcceptedFields [ key_1 ] is AcceptedFields . lang : if to_return [ AcceptedFields . lang . name ] . get ( key_2 ): to_return [ AcceptedFields . lang . name ][ key_2 ] . append ( value ) else : to_return [ AcceptedFields . lang . name ] = { key_2 : [ value ]} elif key_2 == \"gol\" : to_return [ key_1 ] = { key_2 : value } else : to_return [ key_1 ] = { key_2 : [ value ]} return to_return @property def tags ( self ) -> List [ str ]: to_return = list () for tag in self . _tokens . get ( \"tag\" , []): to_return . append ( tag . strip ( \"#\" ) . replace ( \"_\" , \" \" )) return to_return @property def content ( self ) -> str : return self . _tokens [ \"content\" ]","title":"Annotated text"},{"location":"reference/schemas/input/annotated_text/#samudra.schemas.input.annotated_text.AnnotatedText","text":"Bases: pyd . BaseModel Uses regex to annotate text Example body \"This is a string #tag_1 #tag-2 {lang.en:new} {meta.gol:nama}\" Source code in samudra/schemas/input/annotated_text.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class AnnotatedText ( pyd . BaseModel ): \"\"\"Uses regex to annotate text Example body: \"This is a string #tag_1 #tag-2 {lang.en:new} {meta.gol:nama}\" \"\"\" body : str @property def _tokens ( self ) -> Dict [ str , Union [ list , str ]]: to_return = defaultdict ( list ) for match in re . finditer ( REGEX_PATTERN , self . body ): if match . lastgroup : to_return [ match . lastgroup ] . append ( match [ 0 ]) if len ( to_return [ \"content\" ]) > 1 : raise SyntaxError ( { \"message\" : \"Returns {} texts. Expects 1. Unexpected character(s) causes the text to be parsed incorrectly.\" . format ( len ( to_return ) ), \"content\" : \"<?> \" . join ( to_return [ \"content\" ]), \"body\" : self . body , \"tags\" : to_return . get ( \"tag\" ), \"fields\" : to_return . get ( \"field\" ), } ) to_return [ \"content\" ]: str = to_return [ \"content\" ][ 0 ] . strip () return to_return @property def fields ( self ) -> dict : to_eval : Optional [ str ] = self . _tokens . get ( \"field\" , None ) to_return = defaultdict ( dict ) for eval_str in to_eval : key , value = eval_str . strip ( \"{\" ) . strip ( \"}\" ) . split ( \":\" ) key_1 , key_2 = key . split ( \".\" ) if key_1 not in AcceptedFields . __members__ : raise SyntaxError ( f \"Field ' { key_1 } ' not expected. Only { AcceptedFields . __members__ } are expected.\" ) elif key_2 not in AcceptedFields [ key_1 ] . value : raise SyntaxError ( f \"Field ' { key_2 } ' not expected. Only { AcceptedFields [ key_1 ] . value } are expected.\" ) if AcceptedFields [ key_1 ] is AcceptedFields . lang : if to_return [ AcceptedFields . lang . name ] . get ( key_2 ): to_return [ AcceptedFields . lang . name ][ key_2 ] . append ( value ) else : to_return [ AcceptedFields . lang . name ] = { key_2 : [ value ]} elif key_2 == \"gol\" : to_return [ key_1 ] = { key_2 : value } else : to_return [ key_1 ] = { key_2 : [ value ]} return to_return @property def tags ( self ) -> List [ str ]: to_return = list () for tag in self . _tokens . get ( \"tag\" , []): to_return . append ( tag . strip ( \"#\" ) . replace ( \"_\" , \" \" )) return to_return @property def content ( self ) -> str : return self . _tokens [ \"content\" ]","title":"AnnotatedText"},{"location":"reference/schemas/input/query_filter/","text":"","title":"Query filter"},{"location":"reference/schemas/tables/","text":"","title":"Index"},{"location":"reference/schemas/tables/_helper/","text":"","title":" helper"},{"location":"reference/schemas/tables/cakupan/","text":"","title":"Cakupan"},{"location":"reference/schemas/tables/golongan_kata/","text":"","title":"Golongan kata"},{"location":"reference/schemas/tables/kata_asing/","text":"","title":"Kata asing"},{"location":"reference/schemas/tables/konsep/","text":"","title":"Konsep"},{"location":"reference/schemas/tables/lemma/","text":"","title":"Lemma"},{"location":"reference/schemas/tables/user/","text":"DaftarResponse Bases: ORMSchema DaftarResponse Source code in samudra/schemas/tables/user.py 23 24 25 26 27 class DaftarResponse ( ORMSchema ): \"\"\"DaftarResponse\"\"\" pengguna : str mesej : str LogMasukResponse Bases: ORMSchema LogMasukResponse Source code in samudra/schemas/tables/user.py 16 17 18 19 20 class LogMasukResponse ( ORMSchema ): \"\"\"LogMasukResponse\"\"\" pengguna : str token : Token Token Bases: pyd . BaseModel Token Source code in samudra/schemas/tables/user.py 9 10 11 12 13 class Token ( pyd . BaseModel ): \"\"\"Token\"\"\" access_token : str token_type : str","title":"User"},{"location":"reference/schemas/tables/user/#samudra.schemas.tables.user.DaftarResponse","text":"Bases: ORMSchema DaftarResponse Source code in samudra/schemas/tables/user.py 23 24 25 26 27 class DaftarResponse ( ORMSchema ): \"\"\"DaftarResponse\"\"\" pengguna : str mesej : str","title":"DaftarResponse"},{"location":"reference/schemas/tables/user/#samudra.schemas.tables.user.LogMasukResponse","text":"Bases: ORMSchema LogMasukResponse Source code in samudra/schemas/tables/user.py 16 17 18 19 20 class LogMasukResponse ( ORMSchema ): \"\"\"LogMasukResponse\"\"\" pengguna : str token : Token","title":"LogMasukResponse"},{"location":"reference/schemas/tables/user/#samudra.schemas.tables.user.Token","text":"Bases: pyd . BaseModel Token Source code in samudra/schemas/tables/user.py 9 10 11 12 13 class Token ( pyd . BaseModel ): \"\"\"Token\"\"\" access_token : str token_type : str","title":"Token"},{"location":"reference/server/","text":"Module to hold functions relating to server such as routing and setting up.","title":"Server"},{"location":"reference/server/dependencies/","text":"get_db ( db_state = Depends ( reset_db_state )) Gets the database for a server route. TODO As of now, I do not know how to override this for testing. Source code in samudra/server/dependencies.py 17 18 19 20 21 22 23 24 25 26 27 28 def get_db ( db_state = Depends ( reset_db_state )): \"\"\"Gets the database for a server route. !!! important \"TODO\" As of now, I do not know how to override this for testing. \"\"\" try : SERVER_DATABASE . connect () yield finally : if not SERVER_DATABASE . is_closed (): SERVER_DATABASE . close () reset_db_state () async Resetting Database state for a fresh query Source code in samudra/server/dependencies.py 8 9 10 11 12 13 14 async def reset_db_state () -> None : \"\"\"Resetting Database state for a fresh query\"\"\" try : SERVER_DATABASE . _state . _state . set ( db_state_default . copy ()) SERVER_DATABASE . _state . reset () except AttributeError : pass","title":"Dependencies"},{"location":"reference/server/dependencies/#samudra.server.dependencies.get_db","text":"Gets the database for a server route. TODO As of now, I do not know how to override this for testing. Source code in samudra/server/dependencies.py 17 18 19 20 21 22 23 24 25 26 27 28 def get_db ( db_state = Depends ( reset_db_state )): \"\"\"Gets the database for a server route. !!! important \"TODO\" As of now, I do not know how to override this for testing. \"\"\" try : SERVER_DATABASE . connect () yield finally : if not SERVER_DATABASE . is_closed (): SERVER_DATABASE . close ()","title":"get_db()"},{"location":"reference/server/dependencies/#samudra.server.dependencies.reset_db_state","text":"Resetting Database state for a fresh query Source code in samudra/server/dependencies.py 8 9 10 11 12 13 14 async def reset_db_state () -> None : \"\"\"Resetting Database state for a fresh query\"\"\" try : SERVER_DATABASE . _state . _state . set ( db_state_default . copy ()) SERVER_DATABASE . _state . reset () except AttributeError : pass","title":"reset_db_state()"},{"location":"reference/server/setup/","text":"","title":"Setup"},{"location":"reference/server/tokens/","text":"","title":"Tokens"},{"location":"reference/server/routes/","text":"RESTful API Routes for the server","title":"Index"},{"location":"reference/server/routes/auth/","text":"create_pengguna ( pengguna ) POST /auth/daftar . Register user Parameters: Name Type Description Default pengguna PenggunaCreateDTO User required Raises: Type Description HTTPException 409 Exception. User already exist HTTPException 400 Bad Request Exception. Returns: Type Description schemas.DaftarResponse Source code in samudra/server/routes/auth.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @router . post ( \"/daftar\" , response_model = schemas . DaftarResponse ) def create_pengguna ( pengguna : PenggunaCreateDTO ): \"\"\"POST `/auth/daftar`. Register user Args: pengguna (PenggunaCreateDTO): User Raises: HTTPException: 409 Exception. User already exist HTTPException: 400 Bad Request Exception. Returns: [`schemas.DaftarResponse`][samudra.schemas.tables.user.DaftarResponse] \"\"\" try : pengguna = auth . get_pengguna_by_nama ( pengguna . nama ) raise HTTPException ( status_code = 409 , detail = \"User already exist\" ) except models . Pengguna . DoesNotExist : pengguna = auth . create_pengguna ( nama = pengguna . nama , katalaluan = pengguna . katalaluan ) return { \"pengguna\" : pengguna . nama , \"mesej\" : f \"Pengguna { pengguna . nama } telah berjaya didaftarkan!\" , } except SyntaxError as e : raise HTTPException ( status_code = 400 , detail = e . msg ) login_pengguna ( form_data = Depends ()) async POST /auth/logmasuk . Log in. Parameters: Name Type Description Default form_data OAuth2PasswordRequestForm username and password. Defaults to Depends(). Depends() Raises: Type Description HTTPException 401 Unauthorized Exception. Incorrect username or password. HTTPException 400 Bad Request Exception. Returns: Type Description schemas.LogMasukResponse Source code in samudra/server/routes/auth.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 @router . post ( \"/logmasuk\" , response_model = schemas . LogMasukResponse ) async def login_pengguna ( form_data : OAuth2PasswordRequestForm = Depends ()): \"\"\"POST `/auth/logmasuk`. Log in. Args: form_data (OAuth2PasswordRequestForm, optional): username and password. Defaults to Depends(). Raises: HTTPException: 401 Unauthorized Exception. Incorrect username or password. HTTPException: 400 Bad Request Exception. Returns: [`schemas.LogMasukResponse`][samudra.schemas.tables.user.LogMasukResponse] \"\"\" try : pengguna = auth . authenticate_pengguna ( form_data . username , form_data . password ) if not pengguna : raise HTTPException ( status_code = status . HTTP_401_UNAUTHORIZED , detail = \"Incorrect username or password\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : pengguna . nama }, expires_delta = access_token_expires ) return { \"pengguna\" : form_data . username , \"token\" : { \"access_token\" : access_token , \"token_type\" : \"bearer\" }, } except SyntaxError as e : raise HTTPException ( status_code = 400 , detail = e . msg )","title":"Auth"},{"location":"reference/server/routes/auth/#samudra.server.routes.auth.create_pengguna","text":"POST /auth/daftar . Register user Parameters: Name Type Description Default pengguna PenggunaCreateDTO User required Raises: Type Description HTTPException 409 Exception. User already exist HTTPException 400 Bad Request Exception. Returns: Type Description schemas.DaftarResponse Source code in samudra/server/routes/auth.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @router . post ( \"/daftar\" , response_model = schemas . DaftarResponse ) def create_pengguna ( pengguna : PenggunaCreateDTO ): \"\"\"POST `/auth/daftar`. Register user Args: pengguna (PenggunaCreateDTO): User Raises: HTTPException: 409 Exception. User already exist HTTPException: 400 Bad Request Exception. Returns: [`schemas.DaftarResponse`][samudra.schemas.tables.user.DaftarResponse] \"\"\" try : pengguna = auth . get_pengguna_by_nama ( pengguna . nama ) raise HTTPException ( status_code = 409 , detail = \"User already exist\" ) except models . Pengguna . DoesNotExist : pengguna = auth . create_pengguna ( nama = pengguna . nama , katalaluan = pengguna . katalaluan ) return { \"pengguna\" : pengguna . nama , \"mesej\" : f \"Pengguna { pengguna . nama } telah berjaya didaftarkan!\" , } except SyntaxError as e : raise HTTPException ( status_code = 400 , detail = e . msg )","title":"create_pengguna()"},{"location":"reference/server/routes/auth/#samudra.server.routes.auth.login_pengguna","text":"POST /auth/logmasuk . Log in. Parameters: Name Type Description Default form_data OAuth2PasswordRequestForm username and password. Defaults to Depends(). Depends() Raises: Type Description HTTPException 401 Unauthorized Exception. Incorrect username or password. HTTPException 400 Bad Request Exception. Returns: Type Description schemas.LogMasukResponse Source code in samudra/server/routes/auth.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 @router . post ( \"/logmasuk\" , response_model = schemas . LogMasukResponse ) async def login_pengguna ( form_data : OAuth2PasswordRequestForm = Depends ()): \"\"\"POST `/auth/logmasuk`. Log in. Args: form_data (OAuth2PasswordRequestForm, optional): username and password. Defaults to Depends(). Raises: HTTPException: 401 Unauthorized Exception. Incorrect username or password. HTTPException: 400 Bad Request Exception. Returns: [`schemas.LogMasukResponse`][samudra.schemas.tables.user.LogMasukResponse] \"\"\" try : pengguna = auth . authenticate_pengguna ( form_data . username , form_data . password ) if not pengguna : raise HTTPException ( status_code = status . HTTP_401_UNAUTHORIZED , detail = \"Incorrect username or password\" , headers = { \"WWW-Authenticate\" : \"Bearer\" }, ) access_token_expires = timedelta ( minutes = ACCESS_TOKEN_EXPIRE_MINUTES ) access_token = create_access_token ( data = { \"sub\" : pengguna . nama }, expires_delta = access_token_expires ) return { \"pengguna\" : form_data . username , \"token\" : { \"access_token\" : access_token , \"token_type\" : \"bearer\" }, } except SyntaxError as e : raise HTTPException ( status_code = 400 , detail = e . msg )","title":"login_pengguna()"},{"location":"reference/server/routes/golongan_kata/","text":"create_golongan_kata ( post , token = Depends ( oauth2_scheme )) CREATE /golongan/new/ . Creates word class with value defined in post . PROTECTED user token required. Parameters: Name Type Description Default post schemas . CreateGolonganKata A JSON Object to define models.GolonganKata required Returns: Type Description Union [ models . GolonganKata , schemas . CreateGolonganKata ] If successful: GolonganKata . If unsuccessful: schemas.CreateGolonganKata for helpful error messages. Source code in samudra/server/routes/golongan_kata.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @router . post ( \"/new\" ) def create_golongan_kata ( post : schemas . CreateGolonganKata , token : str = Depends ( oauth2_scheme ) ) -> Union [ models . GolonganKata , schemas . CreateGolonganKata ]: \"\"\"CREATE `/golongan/new/`. Creates word class with value defined in `post`. !!! important \"PROTECTED\" user `token` required. Args: post (schemas.CreateGolonganKata): A JSON Object to define [`models.GolonganKata`][samudra.models.core.konsep.GolonganKata] Returns: If successful: [`GolonganKata`][samudra.models.core.konsep.GolonganKata]. If unsuccessful: [`schemas.CreateGolonganKata`][samudra.schemas.input.annotated_text.CreateGolonganKata] for helpful error messages. \"\"\" try : return crud . create_golongan_kata ( data = post ) except ValueError as e : return HTTPException ( status_code = 400 , detail = e )","title":"Golongan kata"},{"location":"reference/server/routes/golongan_kata/#samudra.server.routes.golongan_kata.create_golongan_kata","text":"CREATE /golongan/new/ . Creates word class with value defined in post . PROTECTED user token required. Parameters: Name Type Description Default post schemas . CreateGolonganKata A JSON Object to define models.GolonganKata required Returns: Type Description Union [ models . GolonganKata , schemas . CreateGolonganKata ] If successful: GolonganKata . If unsuccessful: schemas.CreateGolonganKata for helpful error messages. Source code in samudra/server/routes/golongan_kata.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @router . post ( \"/new\" ) def create_golongan_kata ( post : schemas . CreateGolonganKata , token : str = Depends ( oauth2_scheme ) ) -> Union [ models . GolonganKata , schemas . CreateGolonganKata ]: \"\"\"CREATE `/golongan/new/`. Creates word class with value defined in `post`. !!! important \"PROTECTED\" user `token` required. Args: post (schemas.CreateGolonganKata): A JSON Object to define [`models.GolonganKata`][samudra.models.core.konsep.GolonganKata] Returns: If successful: [`GolonganKata`][samudra.models.core.konsep.GolonganKata]. If unsuccessful: [`schemas.CreateGolonganKata`][samudra.schemas.input.annotated_text.CreateGolonganKata] for helpful error messages. \"\"\" try : return crud . create_golongan_kata ( data = post ) except ValueError as e : return HTTPException ( status_code = 400 , detail = e )","title":"create_golongan_kata()"},{"location":"reference/server/routes/lemmas/","text":"create_lemma ( nama , post , token = Depends ( oauth2_scheme )) POST /lemma/{nama} . Inserts the lemma with value nama={nama} and post into the database. PROTECTED user token required Parameters: Name Type Description Default nama str the dictionary entry required post schemas . AnnotatedText An annotated text containing meaning, context, and foreign words. required Raises: Type Description HTTPException 400 Bad Query Exception if it has bad AnnotatedText. Returns: Type Description Union [ models . Konsep , schemas . AnnotatedText ] If successful: Konsep . If unsuccessful: schemas.AnnotatedText for helpful error messages. Source code in samudra/server/routes/lemmas.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @router . post ( \"/ {nama} \" , response_model = schemas . KonsepResponseFromAnnotatedBody ) def create_lemma ( nama : str , post : schemas . AnnotatedText , token : str = Depends ( oauth2_scheme ) ) -> Union [ models . Konsep , schemas . AnnotatedText ]: \"\"\"POST `/lemma/{nama}`. Inserts the lemma with value `nama={nama}` and `post` into the database. !!! important \"PROTECTED\" user `token` required Args: nama (str): the dictionary entry post (schemas.AnnotatedText): An annotated text containing meaning, context, and foreign words. Raises: HTTPException: 400 Bad Query Exception if it has bad AnnotatedText. Returns: If successful: [`Konsep`][samudra.models.core.konsep.Konsep]. If unsuccessful: [`schemas.AnnotatedText`][samudra.schemas.input.annotated_text.AnnotatedText] for helpful error messages. \"\"\" try : to_return = crud . create_konsep_by_annotated_text ( post , lemma_name = nama ) except SyntaxError as e : raise HTTPException ( status_code = 400 , detail = e . msg ) return to_return delete_lemma ( _id , token = Depends ( oauth2_scheme )) DELETE /lemma/id/{_id} . Deletes lemma with value id={_id} PROTECTED user token required Parameters: Name Type Description Default _id int Id of lemma required Returns: Type Description Dict [ str , int ] Returns how many items are deleted. Source code in samudra/server/routes/lemmas.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @router . delete ( \"/id/ {_id} \" , response_model = Dict [ str , int ]) def delete_lemma ( _id : int , token : str = Depends ( oauth2_scheme )) -> Dict [ str , int ]: \"\"\"DELETE `/lemma/id/{_id}`. Deletes lemma with value `id={_id}` !!! important \"PROTECTED\" user `token` required Args: _id (int): Id of lemma Returns: Returns how many items are deleted. \"\"\" lemma = crud . get_lemma_by_id ( _id )[ 0 ] return { \"deleted\" : crud . delete_lemma ( lemma )} get_all_lemma ( limit = Query ( default = None ), cakupan = Query ( default = None ), kata_asing = Query ( default = None )) GET /lemma/ . Queries all lemma within the defined query parameters. Parameters: Name Type Description Default limit Optional [ int ] Limit number of hits. Defaults to Query(default=None). Query(default=None) cakupan Optional [ List [ str ]] Context of meaning. Defaults to Query(default=None). Query(default=None) kata_asing Optional [ List [ str ]] Containing these foreign words. Defaults to Query(default=None). Query(default=None) Returns: Type Description List [ models . Lemma ] List[models.Lemma]: List of Lemma and its meaning. Source code in samudra/server/routes/lemmas.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @router . get ( \"/\" , response_model = List [ schemas . LemmaResponse ]) def get_all_lemma ( limit : Optional [ int ] = Query ( default = None ), cakupan : Optional [ List [ str ]] = Query ( default = None ), kata_asing : Optional [ List [ str ]] = Query ( default = None ), ) -> List [ models . Lemma ]: \"\"\"GET `/lemma/`. Queries all lemma within the defined query parameters. Args: limit (Optional[int], optional): Limit number of hits. Defaults to Query(default=None). cakupan (Optional[List[str]], optional): Context of meaning. Defaults to Query(default=None). kata_asing (Optional[List[str]], optional): Containing these foreign words. Defaults to Query(default=None). Returns: List[models.Lemma]: List of Lemma and its meaning. \"\"\" return crud . get_lemma ( QueryFilter ( limit = limit , cakupan = cakupan , kata_asing = kata_asing ) ) read_lemma ( nama , limit = Query ( default = None ), cakupan = Query ( default = None ), kata_asing = Query ( default = None )) GET /lemma/{nama} . Queries the database for lemma with value nama={nama} . Parameters: Name Type Description Default nama str the dictionary entry required limit Optional [ int ] Limit number of hits. Defaults to Query(default=None). Query(default=None) cakupan Optional [ List [ str ]] Context of meaning. Defaults to Query(default=None). Query(default=None) kata_asing Optional [ List [ str ]] Containing these foreign words. Defaults to Query(default=None). Query(default=None) Raises: Type Description HTTPException 404 Exception if no lemma found in record Returns: Type Description List [ models . Lemma ] List[models.Lemma]: List of Lemma and its meaning. Source code in samudra/server/routes/lemmas.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @router . get ( \"/ {nama} \" , response_model = List [ schemas . LemmaResponse ]) def read_lemma ( nama : str , limit : Optional [ int ] = Query ( default = None ), cakupan : Optional [ List [ str ]] = Query ( default = None ), kata_asing : Optional [ List [ str ]] = Query ( default = None ), ) -> List [ models . Lemma ]: \"\"\"GET `/lemma/{nama}`. Queries the database for lemma with value `nama={nama}`. Args: nama (str): the dictionary entry limit (Optional[int], optional): Limit number of hits. Defaults to Query(default=None). cakupan (Optional[List[str]], optional): Context of meaning. Defaults to Query(default=None). kata_asing (Optional[List[str]], optional): Containing these foreign words. Defaults to Query(default=None). Raises: HTTPException: 404 Exception if no lemma found in record Returns: List[models.Lemma]: List of Lemma and its meaning. \"\"\" db_lemma = crud . get_lemma_by_name ( nama = nama , query = QueryFilter ( limit = limit , cakupan = cakupan , kata_asing = kata_asing ), ) if db_lemma is None : raise HTTPException ( status_code = 404 , detail = \"Lemma not in record\" ) return db_lemma","title":"Lemmas"},{"location":"reference/server/routes/lemmas/#samudra.server.routes.lemmas.create_lemma","text":"POST /lemma/{nama} . Inserts the lemma with value nama={nama} and post into the database. PROTECTED user token required Parameters: Name Type Description Default nama str the dictionary entry required post schemas . AnnotatedText An annotated text containing meaning, context, and foreign words. required Raises: Type Description HTTPException 400 Bad Query Exception if it has bad AnnotatedText. Returns: Type Description Union [ models . Konsep , schemas . AnnotatedText ] If successful: Konsep . If unsuccessful: schemas.AnnotatedText for helpful error messages. Source code in samudra/server/routes/lemmas.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @router . post ( \"/ {nama} \" , response_model = schemas . KonsepResponseFromAnnotatedBody ) def create_lemma ( nama : str , post : schemas . AnnotatedText , token : str = Depends ( oauth2_scheme ) ) -> Union [ models . Konsep , schemas . AnnotatedText ]: \"\"\"POST `/lemma/{nama}`. Inserts the lemma with value `nama={nama}` and `post` into the database. !!! important \"PROTECTED\" user `token` required Args: nama (str): the dictionary entry post (schemas.AnnotatedText): An annotated text containing meaning, context, and foreign words. Raises: HTTPException: 400 Bad Query Exception if it has bad AnnotatedText. Returns: If successful: [`Konsep`][samudra.models.core.konsep.Konsep]. If unsuccessful: [`schemas.AnnotatedText`][samudra.schemas.input.annotated_text.AnnotatedText] for helpful error messages. \"\"\" try : to_return = crud . create_konsep_by_annotated_text ( post , lemma_name = nama ) except SyntaxError as e : raise HTTPException ( status_code = 400 , detail = e . msg ) return to_return","title":"create_lemma()"},{"location":"reference/server/routes/lemmas/#samudra.server.routes.lemmas.delete_lemma","text":"DELETE /lemma/id/{_id} . Deletes lemma with value id={_id} PROTECTED user token required Parameters: Name Type Description Default _id int Id of lemma required Returns: Type Description Dict [ str , int ] Returns how many items are deleted. Source code in samudra/server/routes/lemmas.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @router . delete ( \"/id/ {_id} \" , response_model = Dict [ str , int ]) def delete_lemma ( _id : int , token : str = Depends ( oauth2_scheme )) -> Dict [ str , int ]: \"\"\"DELETE `/lemma/id/{_id}`. Deletes lemma with value `id={_id}` !!! important \"PROTECTED\" user `token` required Args: _id (int): Id of lemma Returns: Returns how many items are deleted. \"\"\" lemma = crud . get_lemma_by_id ( _id )[ 0 ] return { \"deleted\" : crud . delete_lemma ( lemma )}","title":"delete_lemma()"},{"location":"reference/server/routes/lemmas/#samudra.server.routes.lemmas.get_all_lemma","text":"GET /lemma/ . Queries all lemma within the defined query parameters. Parameters: Name Type Description Default limit Optional [ int ] Limit number of hits. Defaults to Query(default=None). Query(default=None) cakupan Optional [ List [ str ]] Context of meaning. Defaults to Query(default=None). Query(default=None) kata_asing Optional [ List [ str ]] Containing these foreign words. Defaults to Query(default=None). Query(default=None) Returns: Type Description List [ models . Lemma ] List[models.Lemma]: List of Lemma and its meaning. Source code in samudra/server/routes/lemmas.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @router . get ( \"/\" , response_model = List [ schemas . LemmaResponse ]) def get_all_lemma ( limit : Optional [ int ] = Query ( default = None ), cakupan : Optional [ List [ str ]] = Query ( default = None ), kata_asing : Optional [ List [ str ]] = Query ( default = None ), ) -> List [ models . Lemma ]: \"\"\"GET `/lemma/`. Queries all lemma within the defined query parameters. Args: limit (Optional[int], optional): Limit number of hits. Defaults to Query(default=None). cakupan (Optional[List[str]], optional): Context of meaning. Defaults to Query(default=None). kata_asing (Optional[List[str]], optional): Containing these foreign words. Defaults to Query(default=None). Returns: List[models.Lemma]: List of Lemma and its meaning. \"\"\" return crud . get_lemma ( QueryFilter ( limit = limit , cakupan = cakupan , kata_asing = kata_asing ) )","title":"get_all_lemma()"},{"location":"reference/server/routes/lemmas/#samudra.server.routes.lemmas.read_lemma","text":"GET /lemma/{nama} . Queries the database for lemma with value nama={nama} . Parameters: Name Type Description Default nama str the dictionary entry required limit Optional [ int ] Limit number of hits. Defaults to Query(default=None). Query(default=None) cakupan Optional [ List [ str ]] Context of meaning. Defaults to Query(default=None). Query(default=None) kata_asing Optional [ List [ str ]] Containing these foreign words. Defaults to Query(default=None). Query(default=None) Raises: Type Description HTTPException 404 Exception if no lemma found in record Returns: Type Description List [ models . Lemma ] List[models.Lemma]: List of Lemma and its meaning. Source code in samudra/server/routes/lemmas.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @router . get ( \"/ {nama} \" , response_model = List [ schemas . LemmaResponse ]) def read_lemma ( nama : str , limit : Optional [ int ] = Query ( default = None ), cakupan : Optional [ List [ str ]] = Query ( default = None ), kata_asing : Optional [ List [ str ]] = Query ( default = None ), ) -> List [ models . Lemma ]: \"\"\"GET `/lemma/{nama}`. Queries the database for lemma with value `nama={nama}`. Args: nama (str): the dictionary entry limit (Optional[int], optional): Limit number of hits. Defaults to Query(default=None). cakupan (Optional[List[str]], optional): Context of meaning. Defaults to Query(default=None). kata_asing (Optional[List[str]], optional): Containing these foreign words. Defaults to Query(default=None). Raises: HTTPException: 404 Exception if no lemma found in record Returns: List[models.Lemma]: List of Lemma and its meaning. \"\"\" db_lemma = crud . get_lemma_by_name ( nama = nama , query = QueryFilter ( limit = limit , cakupan = cakupan , kata_asing = kata_asing ), ) if db_lemma is None : raise HTTPException ( status_code = 404 , detail = \"Lemma not in record\" ) return db_lemma","title":"read_lemma()"}]}